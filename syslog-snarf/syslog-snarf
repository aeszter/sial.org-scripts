#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this document into
# the public domain.
#
# Simple syslogd server for debugging or experimenting with syslog.
#
# Run perldoc(1) on this file for additional documentation.

use strict;
use IO::Socket;

# what address to listen on (default everywhere)
my $bind;

# what port to bind to by default
my $port = 514;

# max message length for incoming data ([RFC 3164] limits this to 1024
# by default, though things might not follow the standards)
my $max_msg_len = 5000;

# to match PRI header plus remaining fields
my $PRI_data_re = qr/^ < (\d{1,3}) > (.*) /x;

# to decode remaining data past the priority into TIMESTAMP, HOSTNAME,
# and MSG fields
my $HEADER_MSG_re = qr/^ ((  # match HEADER, TIMESTAMP for reference
  (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)  # Month
  (?:[ ][ ]\d|[ ]\d\d)   # day of month, '  5' or ' 10'
  [ ] \d\d:\d\d:\d\d)    # timestamp
  ([\w.:-]+))            # HOSTNAME host|IPv4|IPv6 and close HEADER
  [ ] (.*)               # MSG data
/x;

# syslog.h code->name mappings for better output
my %syslog_priorities = (
  0 => 'emerg',
  1 => 'alert',
  2 => 'crit',
  3 => 'err',
  4 => 'warning',
  5 => 'notice',
  6 => 'info',
  7 => 'debug'
);

# TODO some vendors (notably Apple) have fiddled with these to add
# NETINFO and similar... support this by reading these defintions
# from a file?
my %syslog_facilities = (
  0  => 'kern',
  1  => 'user',
  2  => 'mail',
  3  => 'daemon',
  4  => 'auth',
  5  => 'syslog',
  6  => 'lpr',
  7  => 'news',
  8  => 'uucp',
  9  => 'cron',
  10 => 'authpriv',
  11 => 'ftp',
  16 => 'local0',
  17 => 'local1',
  18 => 'local2',
  19 => 'local3',
  20 => 'local4',
  21 => 'local5',
  22 => 'local6',
  23 => 'local7'
);

my $VERSION;
( $VERSION = '$Revision$ ' ) =~ s/[^0-9.]//g;

# parse command-line options
use Getopt::Std;
my %opts;
getopts 'h?b:p:', \%opts;

print_help() if exists $opts{'h'} or exists $opts{'?'};

# no input checking as let IO::Socket handle any errors
$bind = $opts{'b'} if exists $opts{'b'};
$port = $opts{'p'} if exists $opts{'p'};

$SIG{'INT'} = sub { exit 0 };  # control+c handler

# start up the syslog server
my $sock = IO::Socket::INET->new(
  Proto => 'udp',
  ( $bind ? LocalAddr => $bind : () ),
  LocalPort => $port
 )
 or die "error: could not start server: errno=$@\n";

$| = 1;                        # autoflush output

while (1) {
  my ( %message, @errors );
  next unless $sock->recv( $message{'raw'}, $max_msg_len );

  $message{'time_recv'} = time;

  # get various info on the packet in question
  $message{'peerhost'} = gethostbyaddr( $sock->peeraddr, AF_INET )
   || $sock->peerhost;
  $message{'peerport'} = $sock->peerport;

  # see [RFC 3164] for syslog message format details
  $message{'length'} = length($msg_in);
  push @errors, 'message exceeds length limit' if $message{'length'} > 1024;

  if ( $message{'raw'} =~ m/$PRI_data_re/o ) {
    ( $message{'PRI'}, $message{'data'} ) = ( $1, $2 );
  } else {
    push @errors, 'could not parse PRI field';
  }

  if ( $message{'data'} =~ m/$HEADER_MSG_re/o ) {
    (
      $message{'HEADER'},   $message{'TIMESTAMP'},
      $message{'HOSTNAME'}, $mesage{'MSG'}
    )
     = ( $1, $2, $3, $4 );
  } else {
    push @errors, 'could not parse HEADER and MSG fields';
  }

  # decode facility/priority (see [RFC 2234] for PRI part values
  if ( $message{'PRI'} ) {
    # TODO replace with simpler 'int($PRI/8)' and '$PRI%8' ?
    $message{'facility'} = ( $message{'PRI'} & 0x03f8 ) >> 3;
    $message{'priority'} = ( $message{'PRI'} & 0x07 );
  }

  # TODO error checking on facility and priority codes?

  # TODO use template to produce this...
  use Data::Dumper;
  warn Dumper \%message, \@errors;
}

END {
  $sock->close if $sock;
}

# a generic help blarb
sub print_help {
  print <<"HELP";
Usage: $0 [opts]

Simple syslogd server for debugging or experimenting with syslog.

Options for version $VERSION:
  -h/-?  Display this message

  -b bb  Bind to host or address instead of to everything
  -p pp  Use UDP port instead of default ($port)

Run perldoc(1) on this script for additional documentation.

HELP
  exit 100;
}

=head1 NAME

syslog_snarf.pl - Simple syslogd server for debugging syslog

=head1 SYNOPSIS

Close any running syslog daemon (syslogd binds to UDP port 514 even in
client-only mode), then run:

  $ syslog_snarf.pl

=head1 DESCRIPTION

This script is a simple syslog server that binds to the syslog port,
and prints out a formatted message of all incoming syslog messages:

  foo.example.org:514   user.info    testing, testing...

Decoding the syslog protocol is fairly easy; one begins with something
wierd like:

  <14>testing, testing...

The 14 is a specially encoded combination of the facility and priority
codes; it can be extracted using funny bit twiddling operations one
can glean from syslog.h with enough study.

=head2 Normal Usage

  $ syslog_snarf.pl [options]

See L<"OPTIONS"> for details on the command line switches supported.

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note about the script.

=item B<-P> I<port>

Listen on the specified UDP port instead of the default.

=back

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No known bugs.

=head1 SEE ALSO

perl(1), [RFC 3164]

=head1 AUTHOR

Jeremy Mates, http://sial.org/contact/

=head1 COPYRIGHT

The author disclaims all copyrights and releases this document into the
public domain.

=head1 HISTORY

Adapted from udp_echo_serv.pl by Lincoln D. Stein in the text
http://www.modperl.com/perl_networking/ (Chapter 18), plus data from
the Net::Syslog module as well as information in the sys/syslog.h
header file.

=head1 VERSION

$Id$

=cut

