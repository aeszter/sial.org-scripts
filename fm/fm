#!/usr/bin/perl
#
# $Id$
# By Jeremy Mates <mailto:jmates@sial.org>
#
# Parses procmail logfiles.
# 
# For documentation, use the -h option or run perldoc on this script.
#
# Distributed under the Artistic License:
# http://www.sial.org/artistic_license.txt
#
######################################################################
#
# MODULES

#use Date::Calc qw(Decode_Month);
use Carp;
use Getopt::Std;

# for the format() and write() reports
use FileHandle;

# file locking related modules
use Fcntl qw(:DEFAULT :flock);
use IO::Handle;

use strict;
use vars qw:$VERSION:;

######################################################################
#
# CONSTANTS

my (%opts, $procmailrc, $logfile, $days_of_week, $months_of_year,
    $backup, @data, %folders, %folder_sizes, $oldest, $newest,
    $total_messages, $total_size, $machine, $summary, $reverse);

# where to look for the procmailrc...
$procmailrc = $ENV{'HOME'} . '/.procmailrc';

# for matching date field in from line
$days_of_week = '(Sun|Mon|Tue|Wed|Thu|Fri|Sat)';
$months_of_year = '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)';

($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

######################################################################
#
# MAIN

# parse command-line options
getopts('h?srzb:m:', \%opts);

help() if exists($opts{'h'}) || exists($opts{'?'});

# extract backup option, if any
$backup = $opts{'b'} if exists $opts{'b'};

# summary only? (no message log)
$summary = 1 if exists $opts{'s'};

# reverse sort message log?
$reverse = 1 if exists $opts{'r'};

# "machine" output style required?
$machine = $opts{'m'} if exists $opts{'m'};

# first, we find out where the logfile is (command line or automagic)
if (@ARGV) {
    $logfile = shift;
} else {
    $logfile = get_logfile_loc ($procmailrc);
}

# parse through the logfile, feeding various global variables
parse_logfile();

# and print off a pretty little report for fun
print_report();

# see if machine-style output format is required
print_machine($machine) if defined $machine;

######################################################################
#
# SUBROUTINES

# dumps a pretty report to STDOUT...
sub print_report {
    my ($subject, $from, $folder, $size, $date);

    print "Email report from $oldest to $newest\n\n";

    # use format to easily line up everything the way I want...

    # disable notion of "pages" in resulting format
    format_lines_per_page STDOUT 99999999;

    # perl doesn't like format_formfeed on a per-handle basis, ergo:
    $^L = '';

    format STDOUT_TOP = 
Count   Destination                                               Size
----------------------------------------------------------------------
.
    format STDOUT = 
@>>>>   @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<   @>>>>>>>>>>>
commify($folders{$_}), $_, commify($folder_sizes{$_})
.

    foreach (sort { $a cmp $b } keys %folders) {
	write;
    }

# hack to get a "footer" for the above summary including totals...
format_name         STDOUT "FOOTER";

format FOOTER =
----------------------------------------------------------------------
@>>>>                                                     @>>>>>>>>>>>
commify($total_messages), commify($total_size)

.
    write;

unless ($summary) {
    # select new format style
    format_name         STDOUT "MESSAGE";
    format_top_name     STDOUT "MESSAGE_TOP";

    # reset line count to force header
    format_lines_left   STDOUT 0;

    my $order;
    if (defined $reverse) {
	$order = 'newest-at-top';
    } else {
        $order = 'oldest-at-top';
    }

    format MESSAGE_TOP =
Message Summaries by Date (@<<<<<<<<<<<<)                    Time/Size
$order
----------------------------------------------------------------------
.

format MESSAGE =
Subject:  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<   @>>>>>>>
          $subject, $date
~         ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<...
          $subject
From:     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
          $from
~         ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<...
          $from
To:       @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<   @>>>>>>>
          $folder, commify($size)

.

    @data = reverse (@data) if $reverse;

    foreach (@data) {
        # use strict complains if use funky calls, so de-ref 'em...
        $subject = $_->{'_subject'};
	$from    = $_->{'_from'};
	$folder  = $_->{'_folder'};
	$size    = $_->{'_size'};
	$date    = $_->{'_date'};

	# only show size if above certain amount (should be a constant,
	# or even better based on standard deviation above average size!)
	$size = undef unless $size > 10000;

	# format date to my liking, e.g. YYYY-MM-DD HH:MM format
	# just HH:MM now, as that's all I need to see...
	my ($wday, $mon, $day, $time, $year) = split /\s+/, $date;

	# remove seconds from time
	$time =~ s/:\d+$//;

	# convert month to number using Date::Calc
#	$mon = Decode_Month($mon);

#	$date = sprintf("%04d-%02d-%02d %s", $year, $mon, $day, $time);
	$date = $time;

	write;
    }
}
}

# machine-style output format (e.g. easily parsed by a machine)
sub print_machine {
    my $file_loc = shift;

    # open & aquire write lock on the file_loc
    open (FD, ">$file_loc") or die "Error opening $file_loc: $!\n";
    FD->autoflush(1);
    
    unless (flock (FD, LOCK_EX|LOCK_NB)) {
	warn "Waiting for write lock on $file_loc ...\n";
	flock (FD, LOCK_EX);
    }
    
    # delete file just to be sure
    seek     (FD, 0, 0) or die "Problem seeking $file_loc: $!\n";
    truncate (FD, 0) or die "Problem truncating $file_loc: $!\n";
    
    my $oldfh = select(FD); $| = 1;

    # global info
    print "global\tstart\t", $oldest, "\n";
    print "global\tfinish\t", $newest, "\n";
    print "global\tcount\t", $total_messages, "\n";
    print "global\tsize\t", $total_size, "\n";

    # folder info
    foreach (sort { $a cmp $b } keys %folders) {
	print "folder\t", $_, "\t", $folders{$_}, "\t", $folder_sizes{$_}, "\n";
    }

    # message info
    my $t_count = 0;
    foreach (@data) {
	print "message", $t_count, "\tsubject\t", $_->{'_subject'}, "\n";
	print "message", $t_count, "\tfrom\t", $_->{'_from'}, "\n";
	print "message", $t_count, "\tfolder\t", $_->{'_folder'}, "\n";
	print "message", $t_count, "\tsize\t", $_->{'_size'}, "\n";
	print "message", $t_count, "\tdate\t", $_->{'_date'}, "\n";
	$t_count++;
    }

    select ($oldfh);

    flock (FD, LOCK_UN);
    close (FD);
}

# parse procmail's logfile w/ locking using global variables
sub parse_logfile {
    my $count = -1; # track where we are in array of anon hashes

    # open & aquire write lock on the logfile
    open (FD, "+< $logfile") or die "Error opening $logfile: $!\n";
    FD->autoflush(1);
    
    unless (flock (FD, LOCK_EX|LOCK_NB)) {
	warn "Waiting for write lock on $logfile ...\n";
	flock (FD, LOCK_EX);
    }

    # are we backing up the file?
    if (defined $backup) {
	open (BACK, ">$backup") or die "Error opening $backup: $!\n";
	BACK->autoflush(1);

	unless (flock (BACK, LOCK_EX|LOCK_NB)) {
	    warn "Waiting for write lock on $logfile ...\n";
	    flock (BACK, LOCK_EX);
	}

	# zap contents of current backup file (just to be sure)
	seek     (BACK, 0, 0) or die "Problem seeking $backup: $!\n";
	truncate (BACK, 0) or die "Problem truncating $backup: $!\n";
    }
    
    # parse the file
    while (<FD>) {
	# keep backup if necessary
	print BACK $_ if defined $backup;

	chomp;

	if (m/^From\s+(.*?)\s+($days_of_week\s+$months_of_year\s+\d{1,2}\s\d\d:\d\d:\d\d\s\d\d\d\d)/o) {
	    # new From line matched, increment our position in @data array
	    $count++;

	    # and tack various info into anon hash in @data array...
	    $data[$count]->{'_from'} = $1;
	    $data[$count]->{'_date'} = $2;
	}
	if (m/^\s*Subject:\s+(.*)$/) {
	    $data[$count]->{'_subject'} = $1;
	}
	if (m/^\s*Folder:\s+(.*?)\s+(\d+)$/) {
	    $data[$count]->{'_folder'} = $1;
	    $data[$count]->{'_size'} = $2;

	    # keep separate track of folder locs for ease
	    # of lookup at cost of more memory
	    $folders{$1}++;

	    # and also amount of data gone to specific destinations
	    $folder_sizes{$1} += $2;

	    # and some totals for fun
	    $total_messages++;
	    $total_size += $2;
	}
    }

    # this (optionally) erases the logfile
    if (exists $opts{'z'}) {
	seek     (FD, 0, 0) or die "Problem seeking $logfile: $!\n";
	truncate (FD, 0) or die "Problem truncating $logfile: $!\n";
    }
    
    # clean up all our locks/open files
    if (defined $backup) {
	flock (BACK, LOCK_UN);
	close (BACK);
    }

    flock (FD, LOCK_UN);
    close (FD);

    # finally, extract out the oldest & newest dates from
    # the data array using a lot of assumptions
    $oldest = $data[0]->{'_date'};
    $newest = $data[$#data]->{'_date'};
}

# automagically gets logfile location from .procmailrc file,
# single argument is path to the procmailrc file
sub get_logfile_loc {
    my $procmailrc = shift;

    my $logfile;

    open (FILE, $procmailrc) or die "Error opening $procmailrc: $!\n";

    while (<FILE>) {
	chomp;
	# not too sure about formatting allowed in .procmailrc...
	if (m/LOGFILE\s*=\s*(.*)$/) {
	    my $logfile_loc = $1;
	    # convert (potentially) shell-notational logfile loc
	    # to a full pathname (e.g. $HOME/.pm_log -> /home/user/.pm_log)
	    $logfile = `echo $logfile_loc`;
	}
    }
    close (FILE);

    return $logfile;
}

# little generic add commas to data routine...
sub commify {
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}

# a generic help blarb
sub help {
    print <<"HELP";
$0 v.$VERSION
Usage: $0 [options] [LOGFILE]
Purpose: procmail logfile parser.

Options:
  -h/-?  Display this message

  -s     Summary mode only, don't print listing of messages.
  -r     Reverse sort newest messages to top of message list.

  -b xx  Make a backup of the LOGFILE, where xx is the (optional) target.
  -z     Truncate logfile after parsing it.

  -m xx  Export "machine" style output to file xx.

Run perldoc on this script for more documentation.

HELP
    exit;
}

__END__

=head1 NAME

fm.pl - procmail logfile parser.

=head1 SYNOPSIS

Pretty simple, just run:

  $ fm.pl

If you want backups and to zero the manually located logfile once done:

  $ fm.pl -zb ~/.pm_logfile.old ~/.pm_logfile

=head1 DESCRIPTION

fm.pl is a simple procmail logfile parser that shows you how many
messages of what size went where based on the contents of your
procmail logfile.

Ideally, it should be run daily from cron to keep you informed of
where your recent mail has gone, especially if you have folders that
you do not check on a regular basis but might be interested if mail
goes to them.

=head1 USAGE

  $ fm.pl [options] [LOGFILE]

If you omit the path to your promail logfile, fm.pl will attempt to
determine its location from your ~/.procmailrc file. Hence LOGFILE is
an optional argument.

=head1 OPTIONS

fm.pl supports the following command line options:

  -h     Get a brief help blarb

  -s     Print only the count and size summary of the logfile.

By default, a listing of individual messages follows the leading count
summary, which might take up more screen space for quick mail summary
checks.

  -r     Reverse sort the individual message listings.

Setting the reverse mode prints the message listings in a
newest-at-top format instead of the default format which has the most
recent messages down at the bottom of the file.

  -b xx  Save a backup of the LOGFILE to location xx.

By default, no backups of the logfile are made.

  -z     Zap the logfile.

By default, the logfile is preserved.  Set the zap option to zero the
logfile, e.g. when cron is mailing you a daily report.

  -m xx  Save a machine-style output to file xx.

The machine-style probably could be improved, patches welcome. :)

=head1 LICENSE

This script is distributed under the terms of the Artistic License:

http://www.sial.org/artistic_license.txt

=head1 BUGS

Since the .procmailrc may contain shell data for the logfile location,
I'm currently using a unix subshell to expand out the path to a full
string, e.g. $HOME/.pm_logfile to /home/user/.pm_logfile.  As long as
you're on Unix, this should be fine...

=head1 SEE ALSO

cron(1), perl(1), procmail(1), procmailrc(5)

=head1 AUTHOR

Jeremy A. Mates, jmates@sial.org

=cut
