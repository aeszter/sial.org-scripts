#!/usr/bin/perl -w
#
# $Id$
# By Jeremy Mates <mailto:jmates@sial.org>
#
# Parses procmail logfiles.
# 
# For documentation, use the -h option or run perldoc on this script.
#
# Distributed under the Artistic License:
# http://www.sial.org/artistic_license.txt
#
######################################################################
#
# MODULES

use Carp;
use Getopt::Std;

# for the format() and write() reports
use FileHandle;

# file locking related modules
use Fcntl qw(:DEFAULT :flock);
use IO::Handle;

use strict;
use vars qw:$VERSION:;

######################################################################
#
# CONSTANTS

my (%opts, $procmailrc, $logfile, $days_of_week, $months_of_year,
    $backup, @data, %folders, %folder_sizes, $oldest, $newest,
    $total_messages, $total_size, $machine);

# where to look for the procmailrc...
$procmailrc = $ENV{'HOME'} . '/.procmailrc';

# for matching date field in from line
$days_of_week = '(Sun|Mon|Tue|Wed|Thu|Fri|Sat)';
$months_of_year = '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)';

($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

######################################################################
#
# MAIN

# parse command-line options
getopts('h?sb:m:', \%opts);

help() if exists($opts{'h'}) || exists($opts{'?'});

# extract backup option, if any
$backup = $opts{'b'} if exists $opts{'b'};

# "machine" output style required?
$machine = $opts{'m'} if exists $opts{'m'};

# first, we find out where the logfile is (command line or automagic)
if (@ARGV) {
    $logfile = shift;
} else {
    $logfile = get_logfile_loc ($procmailrc);
}

# parse through the logfile, feeding various global variables
parse_logfile();

# and print off a pretty little report for fun
print_report();

# see if machine-style output format is required
print_machine($machine) if defined $machine;

######################################################################
#
# SUBROUTINES

# dumps a pretty report to STDOUT...
sub print_report {
    my ($subject, $from, $folder, $size, $date);

    print "Email report from $oldest to $newest\n\n";

    # use format to easily line up everything the way I want...

    # disable notion of "pages" in resulting format
    format_lines_per_page STDOUT 99999999;

    # perl doesn't like format_formfeed on a per-handle basis, ergo:
    $^L = '';

    format STDOUT_TOP = 
Count   Destination                                       Size (bytes)
----------------------------------------------------------------------
.
    format STDOUT = 
@>>>>   @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<   @>>>>>>>>>>>
$folders{$_}, $_, $folder_sizes{$_}
.

    foreach (sort { $a cmp $b } keys %folders) {
	write;
    }

# hack to get a "footer" for the above summary including totals...
format_name         STDOUT "FOOTER";

format FOOTER =
----------------------------------------------------------------------
@>>>>                                                     @>>>>>>>>>>>
$total_messages, $total_size

.
    write;

# select new format style
format_name         STDOUT "MESSAGE";
format_top_name     STDOUT "MESSAGE_TOP";

# reset line count to force header
format_lines_left   STDOUT 0;

format MESSAGE_TOP =
Message Summaries by Date                                 Size (bytes)
----------------------------------------------------------------------
.

format MESSAGE =
Subject:  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
          $subject
~         ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<...
          $subject
From:     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
          $from
~         ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<...
          $from
To:       @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<   @>>>>>>>
          $folder, $size

.

    foreach (@data) {
	# use strict complains if use funky calls, so de-ref 'em...
	$subject = $_->{'_subject'};
	$from    = $_->{'_from'};
	$folder  = $_->{'_folder'};
	$size    = $_->{'_size'};
	$date    = $_->{'_date'};

	write;
    }
}

# machine-style output format (e.g. easily parsed by a machine)
sub print_machine {
    my $file_loc = shift;

    # open & aquire write lock on the file_loc
    open (FD, ">$file_loc") or die "Error opening $file_loc: $!\n";
    FD->autoflush(1);
    
    unless (flock (FD, LOCK_EX|LOCK_NB)) {
	warn "Waiting for write lock on $file_loc ...\n";
	flock (FD, LOCK_EX);
    }
    
    # delete file just to be sure
    seek     (FD, 0, 0) or die "Problem seeking $file_loc: $!\n";
    truncate (FD, 0) or die "Problem truncating $file_loc: $!\n";
    
    # hmmm... format for machine style? :)
    
    flock (FD, LOCK_UN);
    close (FD);
}

# parse procmail's logfile w/ locking using global variables
sub parse_logfile {
    my $count = -1; # track where we are in array of anon hashes

    # open & aquire write lock on the logfile
    open (FD, "+< $logfile") or die "Error opening $logfile: $!\n";
    FD->autoflush(1);
    
    unless (flock (FD, LOCK_EX|LOCK_NB)) {
	warn "Waiting for write lock on $logfile ...\n";
	flock (FD, LOCK_EX);
    }

    # are we backing up the file?
    if (defined $backup) {
	open (BACK, ">$backup") or die "Error opening $backup: $!\n";
	BACK->autoflush(1);

	unless (flock (BACK, LOCK_EX|LOCK_NB)) {
	    warn "Waiting for write lock on $logfile ...\n";
	    flock (BACK, LOCK_EX);
	}

	# zap contents of current backup file (just to be sure)
	seek     (BACK, 0, 0) or die "Problem seeking $backup: $!\n";
	truncate (BACK, 0) or die "Problem truncating $backup: $!\n";
    }
    
    # parse the file
    while (<FD>) {
	# keep backup if necessary
	print BACK $_ if defined $backup;

	chomp;

	if (m/^From\s+(.*?)\s+($days_of_week\s+$months_of_year\s+\d{1,2}\s\d\d:\d\d:\d\d\s\d\d\d\d)/o) {
	    # new From line matched, increment our position in @data array
	    $count++;

	    # and tack various info into anon hash in @data array...
	    $data[$count]->{'_from'} = $1;
	    $data[$count]->{'_date'} = $2;
	}
	if (m/^\s*Subject:\s+(.*)$/) {
	    $data[$count]->{'_subject'} = $1;
	}
	if (m/^\s*Folder:\s+(.*?)\s+(\d+)$/) {
	    $data[$count]->{'_folder'} = $1;
	    $data[$count]->{'_size'} = $2;

	    # keep separate track of folder locs for ease
	    # of lookup at cost of more memory
	    $folders{$1}++;

	    # and also amount of data gone to specific destinations
	    $folder_sizes{$1} += $2;

	    # and some totals for fun
	    $total_messages++;
	    $total_size += $2;
	}
    }

    # this (optionally) erases the logfile
    unless (exists $opts{'s'}) {
	seek     (FD, 0, 0) or die "Problem seeking $logfile: $!\n";
	truncate (FD, 0) or die "Problem truncating $logfile: $!\n";
    }
    
    # clean up
    if (defined $backup) {
	flock (BACK, LOCK_UN);
	close (BACK);
    }

    flock (FD, LOCK_UN);
    close (FD);

    # finally, extract out the oldest & newest dates from
    # the data array using a lot of assumptions
    $oldest = $data[0]->{'_date'};
    $newest = $data[$#data]->{'_date'};
}

# automagically gets logfile location from .procmailrc file,
# single argument is path to the procmailrc file
sub get_logfile_loc {
    my $procmailrc = shift;

    my $logfile;

    open (FILE, $procmailrc) or die "Error opening $procmailrc: $!\n";

    while (<FILE>) {
	chomp;
	# not too sure about formatting allowed in .procmailrc...
	if (m/LOGFILE\s*=\s*(.*)$/) {
	    my $logfile_loc = $1;
	    # convert (potentially) shell-notational logfile loc
	    # to a full pathname (e.g. $HOME/.pm_log -> /home/user/.pm_log)
	    $logfile = `echo $logfile_loc`;
	}
    }
    close (FILE);

    return $logfile;
}

# a generic help blarb
sub help {
    print <<"HELP";
$0 v.$VERSION
Usage: $0 [options] [LOGFILE]
Purpose: procmail logfile parser.

Options:
  -h/-?  Display this message

  -b xx  Make a backup of the LOGFILE, where xx is the (optional) target.
  -s     Do not truncate logfile after parsing it.

Run perldoc on this script for more documentation.

HELP
    exit;
}

__END__

=head1 NAME

fm.pl - procmail logfile parser.

=head1 SYNOPSIS

Pretty simple, just run:

  $ fm.pl

=head1 DESCRIPTION

fm.pl is a simple procmail logfile parser good for giving you summary
reports about what procmail has been doing with your email.

Ideally, it should be run daily from cron to keep you informed of
where your recent mail has gone, especially if you have folders that
you do not check on a regular basis but might be interested if mail
goes to them.

=head1 USAGE

  $ fm.pl [options] [LOGFILE]

If you omit the path to your promail LOGFILE, fm.pl will attempt to
determine its location from your ~/.procmailrc file. Hence LOGFILE is
an optional argument.

=head1 OPTIONS

fm.pl supports the following command line options:

-h     Get a brief help blarb

-b xx  Save a backup of the LOGFILE to location xx.

By default, no backups of the logfile are made.  Caveat actor.

-s     Save the logfile.

The default behaviour is to truncate the logfile down to nothing once
done parsing it.  Setting -s will preserve the current logfile.

=head1 LICENSE

This script is distributed under the terms of the Artistic License:

http://www.sial.org/artistic_license.txt

=head1 BUGS

Lots, probably.

=head1 SEE ALSO

cron(1), perl(1), procmail(1), procmailrc(5)

=head1 AUTHOR

Jeremy A. Mates, jmates@sial.org

=cut
