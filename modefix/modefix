#!/usr/local/bin/perl
#
# $Id$
# By Jeremy Mates <mailto:jmates@sial.org>
#
# Script to fix permissions/ownerships easily in one swoop, as
# opposed to what I was doing at the command line:
#
# find . -type d -exec chmod 2750 {} \;
# find . -type f -exec chmod 640 {} \;
# find . -exec chown foo:bar {} \;
#
# Which really isn't all that efficient or practical, if you
# want to skip certain files, prune out directories, and
# generally avoid rampaging over the filesystem three times
# in a row.
#
# Distributed under the Artistic License:
# http://www.sial.org/artistic_license.txt

# MODULES

use Carp;
use File::Find;
use Getopt::Std;

use strict;

# CONSTANTS

my (%opts, $dirmode, $filemode, $user, $userid, $group, $groupid, $members, 
    $verbose, $quiet, %badgroups, %badperms);

use vars qw:$VERSION:;
($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

# MAIN

# deal with command line options
getopts('h?p:s:d:f:u:g:vq', \%opts);

help() if exists $opts{'h'} || exists $opts{'?'};

$verbose  = 1 if exists $opts{'v'};
if (exists $opts{'q'}) {
    $verbose = 0;
    $quiet = 1;
}

# read in other arguments with error checking
if (exists $opts{'d'}) {
    $dirmode  = $opts{'d'};
    die "dirmode must be four numbers long, e.g. 0750\n" if 4 != length $dirmode;
}

if (exists $opts{'f'}) {
    $filemode = $opts{'f'};
    die "filemode must be four numbers long, e.g. 0640\n" if 4 != length $filemode;    
}

if (exists $opts{'u'}) {
    $user = $opts{'u'};
    # get userid by name
    $userid = getpwnam $user or 'no such user: ', $user, "\n";
}

if (exists $opts{'g'}) {
    $group    = $opts{'g'};
    # extract more info on the group they gave us
    ($groupid, $members)  = (getgrnam $group)[2,3] or die 'no such group: ', $group, "\n";
}

# read from STDIN if no args left
chomp(@ARGV = <STDIN>) unless @ARGV;

# and flag the help text if nothing from STDIN
help() unless @ARGV;

# loop over the remaining input, looking for dirs and parsing them
foreach ( @ARGV ) {
    unless (-d $_) {
	warn "error: $_ not a directory, skipping\n" if $verbose;
	next;
    }

    find(\&zapit, $_);
}

# now, report on who was a bad user (e.g. is setting the wrong group)
# keys are the uid's of bad users
if (keys %badgroups > 0 && ! $quiet) {
    print "\nUsers owning files with improper groups:\n";
    foreach ( keys %badgroups ) {
	my ($name, $uid, $gid, $gcos, $dir) = (getpwuid $_)[0,2,3,6,7];
	print '  ', $name, ':', $_, ':', $gid, ':', $gcos, ':', $dir, "\t", $badgroups{$_}, "\n";
    }
}

# and same for the permissions on files
if (keys %badperms > 0 && ! $quiet) {
    print "\nUsers owning files with improper permissions:\n";
    foreach ( keys %badperms ) {
	my ($name, $uid, $gid, $gcos, $dir) = (getpwuid $_)[0,2,3,6,7];
	print '  ', $name, ':', $_, ':', $gid, ':', $gcos, ':', $dir, "\t", $badperms{$_}, "\n";
    }
    print "\n";
}

# SUBROUTINES

sub zapit {
    # get current user/group ids off of item
    my ($cur_mode, $cur_uid, $cur_gid) = (lstat)[2,4,5];

    $cur_mode = $cur_mode & 07777; # remove type from mode, leaving permission

    # deal with directories
    if (-d) {
	# see if we should "prune" this directory first
	if (exists $opts{'p'}) {
	    my $results = eval "return 1 if( " . $opts{'p'} . " );";
	    
	    if ($@) {
		chomp($@);
		die "Prune error: ", $@; # croak on errors
	    }
	    
	    if ($results) {
		$File::Find::prune = 1;
		warn "pruned ", $File::Find::name, "\n" if $verbose;
		return;
	    }
	}

	# or whether simply "skipped" over
	if (exists $opts{'s'}) {
	    my $result = eval "return 1 if( " . $opts{'s'} . " );";
	    
	    if($@) {
		chomp($@);
		die "Skip error: ", $@; # croak on errors
	    }
	    
	    if($result) {
		return;
	    }
	}

	# apply mode changes as needed to directory
	if (defined $dirmode) {
	    if (oct($dirmode) != $cur_mode) {
		# show the offending file if verbose on
		print 'MODE', "\t", sprintf("%04o", $cur_mode), "\t", $File::Find::name, "\n" if $verbose;

		# attempt the change
		my $result = chmod oct($dirmode), $_;
		warn "error: chmod on ", $File::Find::name, " failed\n" if $result == 0;
		# log bad permissions
		$badperms{$cur_uid}++;
	    }
	}

    } elsif (-f) {
	# see whether to skip this file
	if (exists $opts{'s'}) {
	    my $result = eval "return 1 if( " . $opts{'s'} . " );";
	    
	    if($@) {
		chomp($@);
		die "Skip error: ", $@; # croak on errors
	    }
	    
	    if($result) {
		return;
	    }
	}

	# set file modes if needed
	if (defined $filemode) {
	    if (oct($filemode) != $cur_mode) {
		# show the offending file if verbose on
		print 'MODE', "\t", sprintf("%04o", $cur_mode), "\t", $File::Find::name, "\n" if $verbose;

		my $result = chmod oct($filemode), $_;
		warn "error: chmod on ", $File::Find::name, " failed\n" if $result == 0;
		# log bad permissions
		$badperms{$cur_uid}++;
	    }
	}
    }

    # same group-change code for both dirs and files here
    # need to merge in the userid change into here as well..
    if ((defined $groupid && $groupid != $cur_gid) || (defined $userid && $userid != $cur_uid)) {
	# set what to change what to, depending :)
	# || alternation doesn't work as 0 (root's id) fails test!
	my $uid_temp = (defined $userid)  ? $userid  : $cur_uid;
	my $gid_temp = (defined $groupid) ? $groupid : $cur_gid;
	
	# yak if verbose
	print 'OLD', "\t", $cur_uid, "\t", $cur_gid, "\t", $File::Find::name, "\n" if $verbose;
	
	my $result = chown $uid_temp, $gid_temp, $_;
	warn "error: chown on ", $File::Find::name, " failed\n" if $result == 0;
	
	# log this change so we know whose been setting bad groups
	$badgroups{$cur_uid}++ if defined $groupid;
    }
}

sub help {
     print <<"HELP";
$0 v.$VERSION
Usage: $0 [options] directories_to_fix_here

$0 is a mode/group fixer for directories.

Options
  -h/?   See this text.  
  -d     Directory mode to set, e.g. '2770'
  -f     File mode to set,      e.g. '0660'
  -u     User name to set,      e.g. 'jdoe'
  -g     Group name to set,     e.g. 'goobers'

  -s xx  Perl expression that will result in the current item (stored in \$_)
         being skipped if the expression turns out to be "true."  Example:

         -s '-d || m/^\\.rsrc\$/' .

         Would skip applying the group change to directories or '.rsrc' files.
         (But would still traverse down into any "skipped" directories!)

  -p xx  Perl expression that will result in the current directory (stored in 
         \$_) being pruned out of the tree, e.g. to skip dot directories:

         -p 'm/^\\../' .

         Both -s and -p expressions should use the shortcut _ operator in
         any stat() calls, to avoid race conditions.

  -v     Verbose mode, shows files fixing.
  -q     Overrides -v, only output will be on chown/chmod failures.

HELP
    exit;
}

__END__
