#!/usr/local/bin/perl
#
# $Id$
# By Jeremy Mates <mailto:jmates@sial.org>
#
# Script to fix permissions/ownerships easily in one fell swoop, as 
# opposed to what I was doing at the command line:
#
# find . -type d -exec chmod 2750 {} \;
# find . -type f -exec chmod 640 {} \;
# find . -exec chown foo:bar {} \;
#
# Which really isn't all that efficient or practical, if you want to
# skip certain files, prune out certain directories, avoid rampaging 
# over the filesystem three times in a row, and not exec chmod/chown
# a few thousand times.
#
# Distributed under the Artistic License:
# http://www.sial.org/artistic_license.txt
#
######################################################################
#
# MODULES

use Carp;
use File::Find;
use Getopt::Std;

use strict;

######################################################################
#
# CONSTANTS

my (%opts, $dirmode, $filemode, $user, $userid, $group, $groupid,
    $verbose, $quiet, %badgroups, %badperms);

use vars qw:$VERSION:;
($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

######################################################################
#
# MAIN

# deal with command line options
getopts('h?p:s:d:f:u:g:vq', \%opts);

help() if exists $opts{'h'} || exists $opts{'?'};

$verbose  = 1 if exists $opts{'v'};
if (exists $opts{'q'}) {
    $verbose = 0;
    $quiet = 1;
}

# read in primary arguments (e.g. bits to set on various files...)

# get directory mode to set
if (exists $opts{'d'}) {
    my $temp_dirmode = $opts{'d'};

    if ($temp_dirmode =~ m/^\d+$/) {
	# paranoid, what me?  never!
	die "dirmode must be four numbers long, e.g. 0750\n" 
	    if 4 != length $temp_dirmode;

	# internal number in oct mode for chmod compatibility
	$dirmode = oct $temp_dirmode;
    } else {
	# function should return an array ref...
	$dirmode = parse_mode($temp_dirmode);
    }
}

# get file mode to set
if (exists $opts{'f'}) {
    my $temp_filemode = $opts{'f'};

    if ($temp_filemode =~ m/^\d+$/) {
	# sanity checking on number supplied
	die "filemode must be four numbers long, e.g. 0640\n" 
	    if 4 != length $temp_filemode;

	# mode stored in chmod-compatible oct format internally
	$filemode = oct $temp_filemode;
    } else {
	$filemode = parse_mode($temp_filemode);
    }
}

# user to set
if (exists $opts{'u'}) {
    my $temp_user = $opts{'u'};

    # by userid, otherwise attemp by user name
    if ($temp_user =~ m/^\d+$/) {
	# check that this userid exists in passwd file
	$user = getpwuid $temp_user or 
	    warn 'warning: userid ', $temp_user, " not found on system\n";
	$userid = $temp_user;

    } else {
	# need the userid, regardless :)
	$userid = getpwnam $temp_user or 
	    die 'no such user: ', $temp_user, "\n";
	$user = $temp_user;
    }
}

# group to set
if (exists $opts{'g'}) {
    my $members; # for sanity checking

    my $temp_group = $opts{'g'};

    # by groupid, otherwise attempt by group name
    if ($temp_group =~ m/^\d+$/) {
	($group, undef, $groupid, $members) = getgrgid $temp_group or 
	    warn 'warning: groupid ', $temp_group, " not found on system\n";

    } else {
	# extract more info on the group they gave us
	($group, undef, $groupid, $members) = getgrnam $temp_group or 
	    die 'no such group: ', $temp_group, "\n";
    }

    # some user/group sanity checking: check whether user is a member
    # of the group in question
    if (exists $opts{'u'} && defined $members) {
	# username had better appear as a word in $members...
	unless ( $members =~ m/\b$user\b/o ) {
	    warn 'warning: ', $user, ' not member of group ', $group, "\n";
	}
    }
}

# read from STDIN if no args left on command line
chomp (@ARGV = <STDIN>) unless @ARGV;

# and flag the help text if nothing from STDIN
help() unless @ARGV;

# loop over the remaining input, looking for dirs and parsing them
foreach ( @ARGV ) {
    unless (-d $_) {
	warn "error: $_ not a directory, skipping\n" if $verbose;
	next;
    }

    find(\&zapit, $_);
}

# now, report on who was a bad user (e.g. is setting the wrong group)
# keys are the uid's of bad users
if (keys %badgroups > 0 && ! $quiet) {
    print "\nUsers owning files with improper groups:\n";
    foreach ( keys %badgroups ) {
	my ($name, $uid, $gid, $gcos, $dir) = (getpwuid $_)[0,2,3,6,7];

	print '  ', $name, ':', $_, ':', $gid, ':', $gcos, ':', 
	$dir, "\t", $badgroups{$_}, "\n";
    }
}

# and same for the permissions on files
if (keys %badperms > 0 && ! $quiet) {
    print "\nUsers owning files with improper permissions:\n";
    foreach ( keys %badperms ) {
	my ($name, $uid, $gid, $gcos, $dir) = (getpwuid $_)[0,2,3,6,7];

	print '  ', $name, ':', $_, ':', $gid, ':', $gcos, ':', 
	$dir, "\t", $badperms{$_}, "\n";
    }
    print "\n";
}

######################################################################
#
# SUBROUTINES
#
# zapit is the File::Find subroutine that gets called for each file

sub zapit {
    # get current user/group ids off of item
    my ($cur_mode, $cur_uid, $cur_gid) = (lstat)[2,4,5];

    # remove type from mode, leaving permission
    $cur_mode = $cur_mode & 07777;

    # deal with directories
    if (-d) {
	# see if we should "prune" this directory first
	if (exists $opts{'p'}) {
	    my $result = eval "return 1 if (" . $opts{'p'} . ");";
	    
	    if ($@) {
		chomp $@;
		die "Prune error: ", $@; # croak on errors
	    }
	    
	    if ($result) {
		$File::Find::prune = 1;
		warn "pruned ", $File::Find::name, "\n" if $verbose;
		return;
	    }
	}

	# or whether simply "skipped" over
	if (exists $opts{'s'}) {
	    my $result = eval "return 1 if (" . $opts{'s'} . ");";
	    
	    if($@) {
		chomp $@;
		die "Skip error: ", $@; # croak on errors
	    }
	    
	    if($result) {
		return;
	    }
	}

	# apply mode changes as needed to directory
	if (defined $dirmode) {
	    my $new_mode;

	    # if ARRAY, do the funky stuff, assume regular octal otherwise
	    if (ref $dirmode eq 'ARRAY') {
		$new_mode = apply_mode($cur_mode, $dirmode);
	    } else {
		$new_mode = $dirmode;
	    }

	    # this next bit could be subroutined w/ the filemode change
	    # code below being identical...
	    if ($new_mode != $cur_mode) {
		# show the offending file if verbose on
		print 'MODE', "\t", 
		sprintf ("%04o", $cur_mode), "\t", 
		$File::Find::name, "\n" if $verbose;

		# attempt the change
		my $result = chmod $new_mode, $_;
		warn "error: chmod on ", 
		$File::Find::name, " failed\n" if $result == 0;

		# log bad permissions
		$badperms{$cur_uid}++;
	    }
	}

    } elsif (-f) {
	# see whether to skip this file
	if (exists $opts{'s'}) {
	    my $result = eval "return 1 if (" . $opts{'s'} . ");";
	    
	    if ($@) {
		chomp $@;
		die "Skip error: ", $@; # croak on errors
	    }
	    
	    if ($result) {
		return;
	    }
	}

	# set file modes if needed
	if (defined $filemode) {
	    my $new_mode;

	    # if ARRAY, do the funky stuff, assume regular octal otherwise
	    if (ref $filemode eq 'ARRAY') {
		$new_mode = apply_mode($cur_mode, $filemode);
	    } else {
		$new_mode = $filemode;
	    }

	    # only perform the chmod if modes are different...
	    if ($new_mode != $cur_mode) {
		# show the offending file if verbose on
		print 'MODE', "\t", 
		sprintf ("%04o", $cur_mode), "\t", 
		$File::Find::name, "\n" if $verbose;
		
		my $result = chmod $new_mode, $_;
		
		warn "error: chmod on ", 
		$File::Find::name, " failed\n" if $result == 0;
		
		# log bad permissions
		$badperms{$cur_uid}++;
	    }
	}
    }

    # same user/group-changing code for both dirs and files here
    if ((defined $groupid && $groupid != $cur_gid) || 
	(defined $userid && $userid != $cur_uid)) {

	# set what to change what to, depending :)
	# || alternation doesn't work as 0 (root's id) fails test!
	my $uid_temp = (defined $userid)  ? $userid  : $cur_uid;
	my $gid_temp = (defined $groupid) ? $groupid : $cur_gid;
	
	# yak if verbose
	print 'OLD', "\t", $cur_uid, "\t", $cur_gid, "\t", 
	$File::Find::name, "\n" if $verbose;
	
	my $result = chown $uid_temp, $gid_temp, $_;
	warn "error: chown on ", 
	$File::Find::name, " failed\n" if $result == 0;
	
	# log this change so we know whose been setting bad groups
	$badgroups{$cur_uid}++ if defined $groupid;
    }
}

# parse_mode takes incoming ug+rw,o-rwx requests and returns
# an array reference suitable for use in apply_mode().
#
# the array for ug+rw,o-rwx should look like ([1,0660],[0,0007])
#                                                sugo
sub parse_mode {
    my $temp_mode = shift;

    my (@temp, @modes, $i);

    @temp = split ',', $temp_mode;

    for ($i = 0; $i < scalar @temp; $i++) {
	warn "dealing with $temp[$i]\n";

	my ($what, $operator, $flags) = split /([+-])/, $temp[$i];

	# test for remove bit, otherwise assume add bit
	if ($operator eq "-") {
	    $modes[$i][0] = 0;
	} else {
	    $modes[$i][0] = 1;
	}

	my $bitmask  = 0000;
	my $value  = 0;
	my $sticky = 0;

	$value += 4 if $flags =~ /r/;
	$value += 2 if $flags =~ /w/;
	$value += 1 if $flags =~ /x/;

	# default to all modes on
	$what = 'ugo' unless defined $what;

	# or all on if they used the 'a' mode
	$what = 'ugo' if $what =~ /a/;

	if ($what =~ /u/) {
	    $bitmask |= oct "0${value}00";
	    $sticky += 4 if $flags =~ /s/;
	}
	if ($what =~ /g/) {
	    $bitmask |= oct "00${value}0";
	    $sticky += 2 if $flags =~ /s/;
	}
	if ($what =~ /o/) {
	    $bitmask |= oct "000${value}";
	    $sticky += 1 if $flags =~ /s/;
	}

	# apply sticky mode to finish off this bitmask
	$bitmask |= oct "${sticky}000";

	$modes[$i][1] = $bitmask;
    }

    return \@modes;
}

# expects file's current mode and a parse_mode array reference
# returns the mode the file should be changed to
sub apply_mode {
    my $cur_mode = shift;
    my $r_mode   = shift;

    my $temp_mode = $cur_mode;

    foreach my $element ( @{$r_mode} ) {
	# &~ removes bitmask in element from file's permissions,
	# | operator adds bitmask in if necessary
	if ($element->[0] == 0) {
	    $temp_mode &= ~$element->[1];
	} else {
	    $temp_mode |= $element->[1];
	}
    }

    return $temp_mode;
}

# a standardized help blarb: should move some of this into perldoc
# format so the blarb is a bit shorter...
sub help {
     print <<"HELP";
$0 version $VERSION
Usage:   $0 [options] dir1 [dir2 dir3 .. dirN]
Purpose: A recursive permissions/ownership fixer.

Options
  -h/?   See this text.  
  -d     Directory mode to set, e.g. '2770'
  -f     File mode to set,      e.g. '0660'
  -u     User name to set,      e.g. 'jdoe'
  -g     Group name to set,     e.g. 'goobers'

  -s xx  Perl expression that will result in the current item (stored in \$_)
         being skipped if the expression turns out to be "true."  Example:

         -s '-d || m/^\\.rsrc\$/' .

         Would skip applying the group change to directories or '.rsrc' files.
         (But would still traverse down into any "skipped" directories!)

  -p xx  Perl expression that will result in the current directory (stored in 
         \$_) being pruned out of the tree, e.g. to skip dot directories:

         -p 'm/^\\../' .

         Both -s and -p expressions should use the shortcut _ operator in
         any stat() calls, to avoid race conditions.

  -v     Verbose mode, shows files fixing.
  -q     Overrides -v, only output will be on chown/chmod failures.

HELP
    exit;
}
