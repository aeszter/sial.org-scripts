#!/usr/bin/perl
#
# $Id$
# By Jeremy Mates <mailto:jmates@sial.org>
#
# For documentation, try the -h option or run perldoc on this file.
#
# Distributed under the Artistic License:
# http://www.sial.org/artistic_license.txt
#
######################################################################
#
# MODULES

use Carp;
use File::Find;
use Getopt::Std;

use strict;

######################################################################
#
# CONSTANTS

my (%opts, $dirmode, $filemode, $user, $userid, $group, $groupid,
    $verbose, $quiet, %badgroups, %badperms);

use vars qw:$VERSION:;
($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

######################################################################
#
# MAIN

# deal with command line options
getopts('h?p:s:d:f:u:g:vq', \%opts);

help() if exists $opts{'h'} || exists $opts{'?'};

$verbose  = 1 if exists $opts{'v'};
if (exists $opts{'q'}) {
    $verbose = 0;
    $quiet = 1;
}

# read in primary arguments (e.g. bits to set on various files...)

# get directory mode to set
if (exists $opts{'d'}) {
    my $temp_dirmode = $opts{'d'};

    if ($temp_dirmode =~ m/^\d+$/) {
	# paranoid, what me?  never!
	die "dirmode must be four numbers long, e.g. 0750\n" 
	    if 4 != length $temp_dirmode;

	# internal number in oct mode for chmod compatibility
	$dirmode = oct $temp_dirmode;
    } else {
	# function should return an array ref...
	$dirmode = parse_mode($temp_dirmode);
    }
}

# get file mode to set
if (exists $opts{'f'}) {
    my $temp_filemode = $opts{'f'};

    if ($temp_filemode =~ m/^\d+$/) {
	# sanity checking on number supplied
	die "filemode must be four numbers long, e.g. 0640\n" 
	    if 4 != length $temp_filemode;

	# mode stored in chmod-compatible oct format internally
	$filemode = oct $temp_filemode;
    } else {
	$filemode = parse_mode($temp_filemode);
    }
}

# user to set
if (exists $opts{'u'}) {
    my $temp_user = $opts{'u'};

    # check whether user:group notation in use...
    ($temp_user, $group) = split ':', $temp_user, 2;

    # by userid, otherwise attempt by user name
    if ($temp_user =~ m/^\d+$/) {
	# check that this userid exists in passwd file
	unless ($user = getpwuid $temp_user) {
	    warn 'warning: userid ', $temp_user, " not found on system\n"
		unless $quiet;
	}
	$userid = $temp_user;

    } else {
	# need the userid, regardless; can't pull out in scalar mode
	# as root's 0 id triggers the or die... :)
	(undef, undef, $userid, undef) = getpwnam $temp_user or 
	    die 'no such user: ', $temp_user, "\n";
	$user = $temp_user;
    }
}

# group to set
if (exists $opts{'g'} || defined $group) {
    my $members; # for sanity checking
    my $temp_group;

    # if group already defined, using -u user:group notation,
    # ignore the -g option!
    if (defined $group) {
	$temp_group = $group;
    } else {
	$temp_group = $opts{'g'};
    }

    # by groupid, otherwise attempt by group name
    if ($temp_group =~ m/^\d+$/) {
	unless (($group, undef, $groupid, $members) = getgrgid $temp_group) {
	    # hmmm, at least Linux doesn't appear to allow me to
	    # set the gid to a non-existant group number in perl...
	    die 'groupid ', $temp_group, " not found on system, quitting\n"
	}
    } else {
	# extract more info on the group they gave us
	($group, undef, $groupid, $members) = getgrnam $temp_group or 
	    die 'no such group: ', $temp_group, "\n";
    }

    # some user/group sanity checking: check whether user is a member
    # of the group in question
    if (exists $opts{'u'} && defined $members) {
	# username had better appear as a word in $members...
	unless ( $members =~ m/\b$user\b/o ) {
	    warn 'warning: ', $user, ' not member of group ', $group, "\n"
		unless $quiet;
	}
    }
}

# read from STDIN if no args left on command line
chomp (@ARGV = <STDIN>) unless @ARGV;

# and flag the help text if nothing from STDIN
help() unless @ARGV;

# loop over the remaining input, looking for dirs and parsing them
foreach ( @ARGV ) {
    unless (-d $_) {
	warn "error: $_ not a directory, skipping\n" if $verbose;
	next;
    }

    find(\&zapit, $_);
}

# now, report on who was a bad user (e.g. is setting the wrong group)
# keys are the uid's of bad users
if (keys %badgroups > 0 && ! $quiet) {
    print "\nUsers owning files with improper groups:\n";
    foreach ( keys %badgroups ) {
	my ($name, $uid, $gid, $gcos, $dir) = (getpwuid $_)[0,2,3,6,7];

	print '  ', $name, ':', $_, ':', $gid, ':', $gcos, ':', 
	$dir, "\t", $badgroups{$_}, "\n";
    }
}

# and same for the permissions on files
if (keys %badperms > 0 && ! $quiet) {
    print "\nUsers owning files with improper permissions:\n";
    foreach ( keys %badperms ) {
	my ($name, $uid, $gid, $gcos, $dir) = (getpwuid $_)[0,2,3,6,7];

	print '  ', $name, ':', $_, ':', $gid, ':', $gcos, ':', 
	$dir, "\t", $badperms{$_}, "\n";
    }
    print "\n";
}

######################################################################
#
# SUBROUTINES
#
# zapit is the File::Find subroutine that gets called for each file

sub zapit {
    # get current user/group ids off of item
    my ($cur_mode, $cur_uid, $cur_gid) = (lstat)[2,4,5];

    # remove type from mode, leaving permission
    $cur_mode = $cur_mode & 07777;

    # deal with directories
    if (-d) {
	# see if we should "prune" this directory first
	if (exists $opts{'p'}) {
	    my $result = eval "return 1 if (" . $opts{'p'} . ");";
	    
	    if ($@) {
		chomp $@;
		die "Prune error: ", $@; # croak on errors
	    }
	    
	    if ($result) {
		$File::Find::prune = 1;
		warn "pruned ", $File::Find::name, "\n" if $verbose;
		return;
	    }
	}

	# or whether simply "skipped" over
	if (exists $opts{'s'}) {
	    my $result = eval "return 1 if (" . $opts{'s'} . ");";
	    
	    if($@) {
		chomp $@;
		die "Skip error: ", $@; # croak on errors
	    }
	    
	    if($result) {
		return;
	    }
	}

	# apply mode changes as needed to directory
	if (defined $dirmode) {
	    my $new_mode;

	    # if ARRAY, do the funky stuff, assume regular octal otherwise
	    if (ref $dirmode eq 'ARRAY') {
		$new_mode = apply_mode($cur_mode, $dirmode);
	    } else {
		$new_mode = $dirmode;
	    }

	    # this next bit could be subroutined w/ the filemode change
	    # code below being identical...
	    if ($new_mode != $cur_mode) {
		# show the offending file if verbose on
		print 'OLDMODE', "\t", 
		sprintf ("%04o", $cur_mode), "\t", 
		$File::Find::name, "\n" if $verbose;

		# attempt the change
		my $result = chmod $new_mode, $_;
		warn "error: chmod on ", 
		$File::Find::name, " failed\n" if $result == 0;

		# log bad permissions
		$badperms{$cur_uid}++;
	    }
	}

    } elsif (-f) {
	# see whether to skip this file
	if (exists $opts{'s'}) {
	    my $result = eval "return 1 if (" . $opts{'s'} . ");";
	    
	    if ($@) {
		chomp $@;
		die "Skip error: ", $@; # croak on errors
	    }
	    
	    if ($result) {
		return;
	    }
	}

	# set file modes if needed
	if (defined $filemode) {
	    my $new_mode;

	    # if ARRAY, do the funky stuff, assume regular octal otherwise
	    if (ref $filemode eq 'ARRAY') {
		$new_mode = apply_mode($cur_mode, $filemode);
	    } else {
		$new_mode = $filemode;
	    }

	    # only perform the chmod if modes are different...
	    if ($new_mode != $cur_mode) {
		# show the offending file if verbose on
		print 'OLDMODE', "\t", 
		sprintf ("%04o", $cur_mode), "\t", 
		$File::Find::name, "\n" if $verbose;
		
		my $result = chmod $new_mode, $_;
		
		warn "error: chmod on ", 
		$File::Find::name, " failed\n" if $result == 0;
		
		# log bad permissions
		$badperms{$cur_uid}++;
	    }
	}
    }

    # same user/group-changing code for both dirs and files here
    if ((defined $groupid && $groupid != $cur_gid) || 
	(defined $userid && $userid != $cur_uid)) {

	# set what to change what to, depending :)
	# || alternation doesn't work as 0 (root's id) fails test!
	my $uid_temp = (defined $userid)  ? $userid  : $cur_uid;
	my $gid_temp = (defined $groupid) ? $groupid : $cur_gid;
	
	# yak if verbose
	print 'OLDUID/GID', "\t", $cur_uid, "\t", $cur_gid, "\t", 
	$File::Find::name, "\n" if $verbose;
	
	my $result = chown $uid_temp, $gid_temp, $_;
	warn "error: chown on ", 
	$File::Find::name, " failed\n" if $result == 0;
	
	# log this change so we know whose been setting bad groups
	$badgroups{$cur_uid}++ if defined $groupid;
    }
}

# parse_mode takes incoming ug+rw,o-rwx requests and returns
# an array reference suitable for use in apply_mode().
#
# the array for ug+rw,o-rwx should look like ([1,0660],[0,0007])
#                                                sugo
sub parse_mode {
    my $temp_mode = shift;

    my (@temp, @modes, $i);

    @temp = split ',', $temp_mode;

    for ($i = 0; $i < scalar @temp; $i++) {
	my ($what, $operator, $flags) = split /([+-])/, $temp[$i];

	# test for remove bit, otherwise assume add bit
	if ($operator eq "-") {
	    $modes[$i][0] = 0;
	} else {
	    $modes[$i][0] = 1;
	}

	my $bitmask  = 0000;
	my $value  = 0;
	my $sticky = 0;

	$value += 4 if $flags =~ /r/;
	$value += 2 if $flags =~ /w/;
	$value += 1 if $flags =~ /x/;

	# default to all modes on
	$what = 'ugo' unless defined $what;

	# or all on if they used the 'a' mode
	$what = 'ugo' if $what =~ /a/;

	if ($what =~ /u/) {
	    $bitmask |= oct "0${value}00";
	    $sticky += 4 if $flags =~ /s/;
	}
	if ($what =~ /g/) {
	    $bitmask |= oct "00${value}0";
	    $sticky += 2 if $flags =~ /s/;
	}
	if ($what =~ /o/) {
	    $bitmask |= oct "000${value}";
	    $sticky += 1 if $flags =~ /s/;
	}

	# apply sticky mode to finish off this bitmask
	$bitmask |= oct "${sticky}000";

	$modes[$i][1] = $bitmask;
    }

    return \@modes;
}

# expects file's current mode and a parse_mode array reference
# returns the mode the file should be changed to
sub apply_mode {
    my $cur_mode = shift;
    my $r_mode   = shift;

    my $temp_mode = $cur_mode;

    foreach my $element ( @{$r_mode} ) {
	# &~ removes bitmask in element from file's permissions,
	# | operator adds bitmask in if necessary
	if ($element->[0] == 0) {
	    $temp_mode &= ~$element->[1];
	} else {
	    $temp_mode |= $element->[1];
	}
    }

    return $temp_mode;
}

# a standardized help blarb, see perldoc stuff for more meat
sub help {
     print <<"HELP";
$0 version $VERSION
Usage:   $0 [options] dir1 [dir2 dir3 .. dirN]
Purpose: A recursive permissions/ownership fixer.

Options
  -h/?   See this text.
  -v     Verbose mode, shows files fixing.
  -q     Overrides -v, only output will be on serious failures.
    
  -d nn  Directory mode to set, e.g. '2770' or 'g+rx,o-rwx'
  -f nn  File mode to set,      e.g. '0660' or 'ug+rw'
  -u uu  User name to set,      e.g. 'jdoe' or '42'
  -g gg  Group name to set,     e.g. 'goobers' or '1492'

  -s xx  Perl expression that will result in the current item
         being skipped if the expression turns out to be "true."
  -p xx  Prune matching diretories from search tree.

Use perldoc on this script for more help.

HELP
    exit;
}

__END__

=head1 NAME

B<modefix.pl> - recursive permission and ownership changer.

=head1 SYNOPSIS

To manually set the directory and file permissions, as well as the
ownerships under /home/john:

B<$ modefix.pl -d 2750 -f 0640 -u john -g doe /home/john>

To ensure all files are group writable, and that "others" do not have
any access whatsoever to the files under the current directory:

B<$ modefix.pl -f g+w,o-rwx .>

=head1 DESCRIPTION

B<modefix.pl> is a pure-perl implementation of the following three shell
commands I was getting tired of typing:

    $ find . -type d -exec chmod 2750 {} \;
    $ find . -type f -exec chmod 640 {} \;
    $ find . -exec chown john:doe {} \;

Which really isn't all that efficient or practical, if you want to
skip certain items, prune out a few directories, avoid rampaging 
over the file system three times in a row, and not exec chmod/chown
a few thousand times.

I also don't trust the -R flag on certain unix utilities.  See the
B<BUGS> section for more details.

This module is distributed under the terms of the Artistic License:

http://www.sial.org/artistic_license.txt

=head1 SYNTAX

The general syntax for calling modefix.pl is:

B<$ modefix.pl [options] dir1 [dir2 dir3 .. dirN]>

B<modefix.pl> also looks for input on STDIN if it runs out of
command line arguments before finding something to work with.

=head1 OPTIONS

B<modefix.pl> accepts a variety of command line options, broken down
into B<Useful Options>, B<Actions>, and B<Search Customization>.

B<Useful Options>

 -h/?   View a brief help blarb.

 -v     Verbose mode, shows files being changed.

Good if you want an audit trail of what the system looked like before
the script ran.

 -q     Overrides -v, only output will be on chown/chmod failures.

The default is to print various warnings, and to generate a little
summary report at the end of what was done.

B<Actions>

At least one of the following four actions is needed to make
the script do something:

 -d xx  Directory mode to set.
 -f xx  File mode to set.

Both mode flags take either a literal mode to set, such as:

 0750  (sticky bit, user bit, group bit, other bit)

Or can take an interpreted expression of arbitrary length and complexity:

 ug+rw,o-rw,o+s  (mode, operator, flags)

Note that later operations can override earlier ones; for example, we
remove all then add user back in:

 -rwxs,u+rw

The various modes recognized are:

 u  user bit
 g  group bit
 o  other bit
 a  all bits

The a mode is shorthand for 'ugo', can also be specified by leaving
off the mode flag, which has the same effect as 'ugo' or 'a'.

There are only two operators:

 +  ensure flags are added to mode
 -  ensure flags are removed from mode

And four different flags:

 x  execute bit (1)
 r  read bit (2)
 w  write bit (4)
 s  set sticky bit, based on mode in expression.

The sticky bit acts as follows:

 u+s  set the suid flag
 g+s  set the sgid flag - atalkd(8) likes this on dirs.
 o+s  set the chmod(1) 't' flag, like on /tmp

See chmod(1) for the background on these arguments.

 -u xx  User name to set
 -g xx  Group name to set

User and group names can either be by name, or by id.  If done by
name, chown need's an id to work with, so there had better be a
corresponding system entry for the name supplied.

Also, unless quiet mode is on, modefix.pl warns if you enter id's that
do not exist on the system, or if the user is not a member of the
specified group.

You can also use the -u user:group syntax common to chmod(1); this
format will cause the -g option to be ignored.

B<Search Customization>

Use the following options to ignore various items in the file system
using perl expressions that get evaluated:

 -s 'expression'

Perl expression that will result in the current item (stored in $_)
being skipped if the expression turns out to be true. Example:

 -s '-d || m/^\.rsrc$/'

Would skip applying the changes to any directories or items named
'.rsrc'. B<Warning>: skip only counts towards whether or not any
actions are performed; modefix.pl will happily apply changes below a
"skipped" directory.

 -p 'expression'

Perl expression that will result in the current directory (stored in
$_) and anything below that directory being utterly removed from
examination, in this case any "dot" directories:

 -p 'm/^\../' .

Both -s and -p expressions should use the shortcut _ operator in any
stat() calls, to avoid race conditions.

=head1 BUGS

B<modefix.pl> doesn't deal well with soft links.  Well, File::Find has
trouble with directories, and I'm using lstat, and you can't really
chmod the soft link to a file...

(I've seen systems taken out by rampant chmod -R invocations.  Well, a 
single Solaris system, and it was the kid's first week on the job-- 
wasn't me, and I'm not telling who. :)

=head1 SEE ALSO

chmod(1), chown(1), find(1), perl(1)

=head1 AUTHOR

Jeremy A. Mates, jmates@sial.org

=cut
