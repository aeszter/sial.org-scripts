#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Interacts with pastebot sites:
# http://sourceforge.net/projects/pastebot/
#
# Run perldoc(1) on this file for additional documentation.

require 5;
use strict;
use File::Basename;
use File::Path;
use URI;

my $prefs_file = $ENV{PBOTUTILCONF} || '~/.pbotutil/servers';

$prefs_file = tilde_expand($prefs_file);
init($prefs_file) unless -e $prefs_file;
my $servers = server_load({filename => $prefs_file});
my $aliases = parse_aliases($servers);

# parse pre-verb command-line options
use Getopt::Std;
my %opts;
getopts('h?qu:s:c:m:', \%opts);
help() if exists $opts{'h'} or exists $opts{'?'};

# action table
my %actions = (
  get => {
    description => 'Download pastes from pastebot site',
    handle      => \&pb_get,
  },
  put => {
    description => 'Paste to pastebot site',
    handle      => \&pb_put,
  },
  'list-servers' => {
    description => 'Lists server definitions',
    handle      => \&list_servers,
  },
);

# figure out what to do
my $verb;
if (defined $ARGV[0]) {
  if (exists $actions{$ARGV[0]}) {
    $verb = shift;
  } elsif (exists $servers->{$ARGV[0]}) {
    $verb = 'put';
    $opts{s} = shift;
  }
} else {
  $verb = 'put';
}
unless (exists $actions{$verb}) {
  remark('alert', "no such action: $verb") and exit 101;
}

if ($verb eq 'put') {
  my %args;
  @args{qw(name nick channel summary)} = @opts{qw(s u c m)};

  # also need to pull args from after the put verb and merge them over
  # the pre-put arguments
  my %putopts;
  getopts('s:c:m:u:', \%putopts);
  my %postargs;
  @postargs{qw(name nick channel summary)} = @putopts{qw(s u c m)};

  while (my ($k, $v) = each %postargs) {
    $args{$k} = $v if defined $v;
  }

  help() unless exists $args{name} and defined $args{name};

  # lookup aliases, pre-populate potential servers with name fields
  my @potentials;
  if (exists $aliases->{$args{name}}) {
    push @potentials, @{$aliases->{$args{name}}};
    $args{name} = $aliases->{$args{name}}->[0];
  }

  unless (exists $servers->{$args{name}}) {
    remark('alert', "no preferences entry for: $args{name}");
    exit 105;
  }

  # pull paste data into memory: expect small files, and saving off to a
  # temp file adds a lot of extra code
  my $paste = do { local $/; <> };
  unless (defined $paste) {
    remark('notice', 'quitting as no data to paste');
    exit 105;
  }

  # look for entries we can fail over to if named site down
  my $primary = $servers->{$args{name}};
  push @potentials, $args{name};

  # network and channel same mean multiple pastebots for channel
  if ($primary->{network} ne '') {
    push @potentials, grep {
           $servers->{$_}->{name} ne $primary->{name}
       and $servers->{$_}->{network} eq $primary->{network}
       and $servers->{$_}->{channel} eq $primary->{channel}
    } keys %$servers;
  }

  # can also fallback to entries without channels; these should not be
  # announced anywhere: better to paste somewhere than fail if all the
  # announcing ones are unavailable
  push @potentials, grep { $servers->{$_}->{channel} eq '' } keys %$servers;

  # screen out same url on assumption url being down more common than a
  # channel-specific problem with the paste site (the site having
  # removed support for the channel in question)
  {
    my %seen;
    @potentials = grep { not $seen{$servers->{$_}->{url}}++ } @potentials;
  }

  for my $prefs (map { $servers->{$_} } @potentials) {

    # merge command-line prefs over server entry
    while (my ($k, $v) = each %args) {
      $prefs->{$k} = $v if defined $v;
    }

    last if $actions{$verb}->{handle}->($prefs, \$paste);
  }

} else {
  $actions{$verb}->{handle}->(@ARGV);
}

# handles downloads from paste sites
sub pb_get {
  my $id = shift || help();
  my $url;

  # if get a URL, run with that; otherwise expect shortcut and paste id
  my $urltmp = URI->new($id . (($id !~ m,\?tx=on$,) ? '?tx=on' : ''));

  if (defined $urltmp and defined $urltmp->scheme) {
    $url = $urltmp->canonical;

  } else {

    unless (exists $opts{s} and defined $opts{s}) {
      help();
    } else {
      unless (exists $servers->{$opts{s}}) {
        remark('alert', "no server entry for: $opts{s}");
        exit 105;

        # KLUGE assume pastebot id numeric
      } elsif ($id !~ m/^\d+$/) {
        remark('alert', "could not parse paste id: $id");
        exit 105;

      } else {
        $url =
         URI->new($servers->{$opts{s}}->{url}
           . (($servers->{$opts{s}}->{url} !~ m,/$,) ? '/' : '')
           . $id
           . '?tx=on')->canonical;

        unless (defined $url) {
          remark('alert', "could not determine url for: $id");
          exit 102;
        }
      }
    }
  }
  my $content = get_url({url => $url});
  unless ($content) {
    remark('alert', "no data from $url");
    exit 103;
  }

  print $$content;

  # KLUGE trailing newline if none to prevent shell from gobbling any
  # last line
  print "\n" if $$content !~ m/\n$/;
}

# uploads data to specified paste server
# returns 1 on success, undef on failure, or exits script on serious
# problems
sub pb_put {
  my $prefs = shift;
  my $paste = shift;

  my $url =
   URI->new($prefs->{url} . (($prefs->{url} !~ m,/$,) ? '/' : '') . 'paste')
   ->canonical;

  unless (defined $url) {
    remark('alert', "could not determine url from $prefs->{url}");
    exit 104;
  }

  # ensure non-null channel prefixed with #
  $prefs->{channel} =~ s/^/#/
   if $prefs->{channel} ne ''
   and $prefs->{channel} !~ /^#/;

  # TODO merge this check with other eval for get routine/create global
  # for a LWP object if required?  Also option to support other things
  # if LWP not available might be nice.
  eval { require LWP::UserAgent; };
  if ($@) {
    remark('alert', "problem loading LWP::UserAgent: $@");
    exit 102;
  } else {
    my $ua =
     LWP::UserAgent->new(env_proxy => 1, keep_alive => 0, timeout => 17);

    my %postargs = map { $_ => $prefs->{$_} }
     grep { defined $prefs->{$_} and $prefs->{$_} ne '' }
     qw(channel nick summary);
    $postargs{paste} = $$paste;

    my $response = $ua->post($url, \%postargs);

    if ($response->is_success) {
      if ($response->content and not exists $opts{q}) {
        eval { require HTML::TokeParser; };
        if ($@) {
          remark('alert', "problem loading HTML::TokeParser: $@");

          #print $$content, "\n"; # DBG
          exit 103;
        } else {
          my $p = HTML::TokeParser->new(\$response->content);

          # look for paste URL, print for user
          $p->get_tag('a');
          print $p->get_text('/a'), "\n";
        }
      }
      return 1;
    } else {
      if ($response->is_error) {
        my $error;
        ($error) = $response->error_as_HTML =~ /^(\d{3}.+)/m;
        remark('warning', "error posting to $url: $error");
      } else {
        remark('warning', "error posting to $url: unknown error");
      }
      return;
    }
  }
}

# list server definitions, exits scripts.  for tab completion
sub list_servers {
  print join ("\n", sort keys %$servers, keys %$aliases), "\n";
  exit;
}

# accepts hash containing url to get plus other stuff
# returns scalar reference with page content, or undef if problem
sub get_url {
  my $data = shift;

  # TODO support faster things, like HTTP::GHTTP here, or maybe fall
  # back to command line utils if nothing installed CPAN-wise
  eval { require LWP::UserAgent; };
  if ($@) {
    remark('alert', "problem loading LWP::UserAgent: $@");
    exit 102;
  } else {
    my $ua =
     LWP::UserAgent->new(env_proxy => 1, keep_alive => 0, timeout => 17);
    my $response = $ua->get($data->{url});

    unless ($response->is_success) {
      if ($response->is_error) {
        my $error;
        ($error) = $response->error_as_HTML =~ /^(\d{3}.+)/m;
        remark('warning', "error fetching $data->{url}: $error");
        return;
      } else {
        remark('warning', "error fetching $data->{url}: unknown error");
        return;
      }
    }
    return \$response->content();
  }
}

# pulls prefs file off disk or something like that
sub server_load {
  my $data = shift;
  my (@tmp, $servers);

  push @tmp, {};

  open FILE, $data->{filename}
   or remark('alert', "could not open $data->{filename} for reading: $!")
   and exit 100;

  while (<FILE>) {
    chomp;
    s/^\s+//;
    next if /^#/;

    # treat blank lines as record seperators, if have enough to work with
    if (/^$/ and exists $tmp[-1]->{name} and exists $tmp[-1]->{url}) {
      push @tmp, {};
      next;
    }

    s/\s+$//;

    my ($k, $v) = split /\s+/, $_, 2;
    unless (defined $k and $k =~ /^[\w.-]+$/ and defined $v) {
      remark('warning', "skipping invalid data at $data->{filename} line $.");
      next;
    }
    $tmp[-1]->{$k} = $v;
  }
  close FILE;

  # validate found records before moving them into $servers
  my $count;
  for my $server (@tmp) {
    next unless keys %{$server};
    $count++;

    unless (exists $server->{name} and defined $server->{name}) {
      remark('warning', "skipping entry $count due to missing name parameter");
      next;
    }
    unless ($server->{name} =~ /^[\w.-]+$/) {
      remark('warning', "skipping entry $count due to invalid name parameter");
      next;
    }

    unless (exists $server->{url} and defined $server->{url}) {
      remark('warning',
"skipping entry $count named $server->{name} due to missing url parameter"
      );
      next;
    }

    if (exists $servers->{$server->{name}}) {
      remark('warning',
        "skipping entry $count due to previous entry named $server->{name}");
      next;
    }

    # empty strings for optional stuff to avoid uninitialized value warnings
    for my $key (qw(channel nick network)) {
      $server->{$key} = ''
       unless exists $server->{$key}
       and defined $server->{$key};
    }
    $server->{count} = $count;

    $servers->{$server->{name}} = $server;
  }

  unless (keys %$servers) {
    remark('alert', "no entries found in preferences file $data->{filename}");
    exit 100;
  }
  return $servers;
}

# accepts $servers HoH, returns $aliases thingy
sub parse_aliases {
  my $servers = shift;
  my %aliases;

  for my $key (keys %$servers) {
    my $s = $servers->{$key};
    next unless defined $s->{alias};
    for my $alias (split /\s+/, $s->{alias}) {
      unless (defined $alias and $alias =~ /^[\w.-]+$/) {
        remark('warning', "skipping alias for entry $s->{count} as invalid");
        next;
      }
      push @{$aliases{$alias}}, $s->{name};
    }
  }

  return \%aliases;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  my @tmp;
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam($1))[7] : ( $ENV{HOME} || $ENV{LOGDIR} )
     }ex;
  }
  return wantarray ? @_ : "@_";
}

sub init {
  my $file = shift;

  # warnings on modules may need
  eval { require LWP::UserAgent; };
  remark('notice', "LWP::UserAgent may be needed, but failed to load: $@")
   if $@;
  eval { require HTML::TokeParser; };
  remark('notice', "HTML::TokeParser may be needed, but failed to load: $@")
   if $@;

  remark('info', "creating default preference file: $file");
  mkpath(dirname($file));
  open FILE, ">$file"
   or remark('alert', "could not create preference file $file: $!")
   and exit 100;

  print FILE <<"DEFAULTPREFS";
# documentation on this file and the associated script can be found by
# running perldoc(1) on $0

# freenode.net, #perl
name perl
url http://sial.org/pbot/
channel #perl
network freenode

# another irc.freenode.net, #perl
name perlalt
url http://dragon.cbi.tamucc.edu:8080/
channel #perl
network freenode

# for non-announced pastes
name nochan-sial
alias nochan test
url http://sial.org/pbot/

name nochan-dragon
alias nochan
url http://dragon.cbi.tamucc.edu:8080/
DEFAULTPREFS

  close FILE or remark('warning', "problem closing write to $file: $!");
}

# generic message handler
sub remark {
  my ($facility, $priority, $message);
  $facility = 'user';

  if (@_ > 1) {
    $priority = shift;
    $message  = "@_";
  } else {
    $priority = 'info';
    $message  = "@_";
  }

  return 1 if exists $opts{'q'} and $priority eq 'info';

  warn $priority, ": ", $message, "\n";

  return 1;
}

# a generic help blarb
sub help {
  print <<"HELP";
Usage for $0:

  Download (to stdout):

$0 -s shortcut get pasteid

  Upload (from files or stdin).  Shortcut is name field from
  a server preferences file entry.

$0 -s shortcut [-c channel] [-m summary] [-u nick] [files]

  Run perldoc(1) on this script for additional documentation, and also
  see the preferences file: $prefs_file

HELP
  exit 1;
}

######################################################################
#
# DOCUMENTATION

=head1 NAME

pbotutil - interacts with pastebot sites

=head1 SYNOPSIS

Get post number 1 using the "perl" shortcut, save to "file":

  $ pbotutil -s perl get 1 > file

Post contents of "file" to the #linux channel available on the same
server that is referenced by the "perl" shortcut.

  $ pbotutil -s perl -c linux -u mynick file

See L<"FILES"> for details on the preferences file, where shortcuts
are defined.

=head1 DESCRIPTION

=head2 Overview

Provides a command line interface to pastebot sites offered by various
IRC channels to prevent paste floods.  Methods to upload files to
pastebots or download specific entries are provided, to spare command
line junkies the trouble of copying and pasting into a browser.

For more information on pastebots, see:

http://sourceforge.net/projects/pastebot/

=head2 Normal Usage

  $ pbotutil [global-options] action [args]

The C<action> can be one of get or put at present.  The put verb is the
default option, and will be assumed if left out.

=over 4

=item B<get>

The get verb accepts two formats: a shortcut lookup plus a pasteid
(number) or a fully qualified URL to download.  A URL will be looked for
first; failing that, a -s shortcut and numeric pasteid are required.

  $ pbotutil get URL

  $ pbotutil -s shortcut get pasteid

Output will be sent to stdout by default.

=item B<put> (default)

The text "put" is optional, and will be assumed if left out. If multiple
files are specified on the command line, they will be joined together
and then pasted. Otherwise, input will be read from stdin. A server to
upload to is required. Additionally, this script will look through the
server entries for alternates to upload to, should the upload fail.

The paste URL will be returned to stdout, unless the quiet mode is on.

  $ pbotutil -s shortcut [-c channel] [-m summary] [-u nick] \
   [put] [-c channel] [-m summary] [-u nick] [files]

  $ pbotutil [-c channel] [-m summary] [-u nick] \
   [put] URL [-c channel] [-m summary] [-u nick] [files]

The -s and the URL arguments are exclusive, though one is required to
obtain a pastebot URL to talk to.  Some options appear on either side of
the optional put verb: options after the verb (if specified) override
those before the verb, and command line options trump any server
preference settings.

This allows shell aliases to be created while still offering the ability
to override the defaults, to avoid faux pas.  The example below is
somewhat contrived, as a better solution would be to create a different
preferences file entry for python posts.

  $ alias pbup='pbotutil -s perl -u perlguru put'
  $ pbup -c python -u pythonguru foo.py

=item B<list-servers>

Provides a list of C<name> (and C<alias>) entries from the preferences
file. For tab completion systems needing to complete the value of the
B<-s> option.  For instance, a primitive zsh compdef entry:

  #compdef pbotutil

  local expl ret=1

  if [[ ${words[CURRENT-1]} = "-s" ]]; then
    _wanted openmethod expl 'server names' compadd "$@" - \
      $(_call_program openm pbotutil list-servers) && ret=0
  fi

  return ret

=back

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note.

=item B<-q>

Makes the script less chatty about various things.

=item B<-s> I<shortcut>

Use a I<shortcut> definition to get the URL, default nickname, and other
details from the preference file.  Optional, as the get and put commands
accept fully qualified URL, though recommended to simplify useage.

See L<"FILES"> for details on the preference file format.

=item B<-c> I<channel>

Channel the pastebot should send the "new paste" notice to.  Overrides
preference file setting, if any.  Setting it to an empty string will
target the "null" channel, which avoids channel announcements; this good
for testing.

  $ date | pbotutil -s test -c ''

=item B<-u> I<nick>

Use I<nick> as username when posting.  Will override the preference file
setting, if any.  This allows channel members to associate a paste with
your nick.

=item B<-m> I<summary>

Short, descriptive summary about the data being pasted, to assist the
members of channel being notified.  This does not include things like
"help!"  For more details on asking questions, see:

http://www.catb.org/~esr/faqs/smart-questions.html

=back

=head1 FILES

A preferences file is used to store server definitions. The location
of the preferences file can be set with the C<PBOTUTILCONF>
environment variable; otherwise, a default file location will be used.
The preferences file will be created using built-in defaults should
none be found.

The file currently uses key/value listings that specify at minimum a
C<name> for the server (for the B<-s> command line option), the URL of
the pastebot site in question, and a C<type>. A default C<nick>,
C<channel>, and C<network> may also be set. The C<alias> entry allows
alternate names to be set for a particular server (space separated
list). Aliases can be identical for multiple server entries, and the
script will failover between the named sites.

  # freenode.net, #perl
  name perl
  alias pp
  url http://sial.org/pbot/
  channel #perl
  network freenode

  # another irc.freenode.net, #perl
  name perlalt
  url http://dragon.cbi.tamucc.edu:8080/
  channel #perl
  network freenode

  # for non-announced pastes or testing
  name nochan-sial
  alias nochan test
  url http://sial.org/pbot/

  name nochan-dragon
  alias nochan
  url http://dragon.cbi.tamucc.edu:8080/

The C<channel> and C<nick> keys provide defaults to use, though will be
overridden by the appropriate command line options. The C<network> field
allows this script to figure out alternative servers to attempt to paste
to, should the specified site be down. The C<type> entry is reserved for
potential future support of other pastebot-style sites.

=head1 EXAMPLES

The script can be used on the command line, or called from an IRC
program.  For instance, the following allows one to type or paste input
into the terminal for upload.

  /exec gnome-terminal -e "pbotutil -s perl -m '&2' put"

Consult your IRC program's manual for more details on how to
invoke scripts.

On Mac OS X, the contents of the clipboard can be pasted from the
command line:

  $ pbpaste | pbotutil -s server -m "my code"

An Emacs interface is available:

http://tierra.dyndns.org:81/emacs/pastebot

=head1 DIAGNOSTICS

There are magic number exit codes.  See source.  :)

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No known issues.

=head1 TODO

See C<TODO> comments in source for things that may need working on.

Way to set default nick, other server defaults. Probably via
default_nick and similar statements in config file.

Support for other pastebot sites, via 'type' setting. Would require
implementation specific get/post routines for the type in question.

Means to use other WWW implementations besides LWP::UserAgent?

=head1 SEE ALSO

perl(1), LWP::UserAgent, HTML::TokeParser

=head1 AUTHOR

Jeremy Mates, http://sial.org/contact/

Patches, examples from evilgwynie of #perl on irc.freenode.net.

=head1 COPYRIGHT

The author disclaims all copyrights and releases this script into the
public domain.

=head1 VERSION

  $Id$

=cut

