#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Interacts with pastebot sites:
# http://sourceforge.net/projects/pastebot/
#
# Run perldoc(1) on this file for additional documentation.

require 5;
use strict;

use File::Basename;
use File::Path;

use URI;

# where preference files are stored
my %pfiles = (servers => '~/.pbotutil/servers');

my $prefs_updated = 0;

# action table
my %actions = (
  get => {
    description => 'Download pastes from pastebot site',
    handle      => \&pb_get,
  },
  put => {
    description => 'Paste to pastebot site',
    handle      => \&pb_put,
  },
  up => {
    description => 'Obtain channel data from pastebot site',
    handle      => \&pb_update,
  },
);

my $VERSION;
($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

######################################################################
#
# MAIN

# parse command-line options
use Getopt::Std;
my %opts;
getopts('h?qu:s:', \%opts);
help() if exists $opts{'h'} or exists $opts{'?'};

for (keys %pfiles) {
  $pfiles{$_} = tilde_expand($pfiles{$_});

  # create prefs files automagcially
  unless (-e $pfiles{$_}) {
    remark('info', "creating preference file: $pfiles{$_}");
    mkpath(dirname($pfiles{$_}));
    open TOUCH, ">$pfiles{$_}"
     or remark('alert', "could not touch preference file $pfiles{$_}: $!")
     and exit 100;
    close TOUCH;
  }
}

# having no servers may or may not be a good thing
# TODO locking on the prefs file or somthing
my $servers = server_load({filename => $pfiles{servers}});

# figure out what to do
my $verb = shift or help();
unless (exists $actions{$verb}) {
  remark('alert', "no such action: $verb") and exit 101;
}
$actions{$verb}->{handle}->(@ARGV);

# TODO this probably needs locking in conjunction with reading above
if ($prefs_updated) {
  server_save({filename => $pfiles{servers}, data => $servers});
}

exit;

######################################################################
#
# SUBROUTINES

sub pb_get {
  my $id = shift;
  my ($url, $content);

  # look for server alias + paste id, or fully qualified URL to nab
  if (exists $opts{s} and exists $servers->{$opts{s}}) {
    $url =
     URI->new($servers->{$opts{s}}->{url}
       . (($servers->{$opts{s}}->{url} !~ m,/$,) ? '/' : '')
       . $id)->canonical;
  } else {
    $url = URI->new($id)->canonical;
  }

  unless (defined $url) {
    remark('alert', "could not determine url for: $id");
    exit 102;
  }
  $content = get_url({url => $url});

  if ($content) {
    eval { require HTML::TokeParser; };
    if ($@) {
      remark('alert', "problem loading HTML::TokeParser: $@");

      #print $$content, "\n";
      exit 103;
    } else {
      require HTML::TokeParser;
      my $p = HTML::TokeParser->new($content);

      # TODO pull out "From" and "Summary" data if wanted?

      # look for stuff in <pre> and evict HTML crap
      $p->get_tag('pre');

      # TODO option to dump to file named after id, instead of just stdout
      print $p->get_text('/pre'), "\n";
    }
  }
}

# accepts hash containing url to get plus other stuff
# returns scalar reference with page content, or undef if problem
sub get_url {
  my $data = shift;

  # TODO support faster things, like HTTP::GHTTP here, or maybe fall
  # back to command line utils if nothing installed CPAN-wise
  eval { require LWP::UserAgent; };
  if ($@) {
    remark('alert', "problem loading LWP::UserAgent: $@");
    exit 102;
  } else {
    require LWP::UserAgent;
    my $ua =
     LWP::UserAgent->new(env_proxy => 1, keep_alive => 0, timeout => 17);
    my $response = $ua->get($data->{url});

    unless ($response->is_success) {
      if ($response->is_error) {
        my $error;
        ($error) = $response->error_as_HTML =~ /^(\d{3}.+)/m;
        remark('warning', "error fetching $data->{url}: $error");
        return;
      } else {
        remark('warning', "error fetching $data->{url}: unknown error");
        return;
      }
    }
    return \$response->content();
  }
}

# pulls prefs file off disk or something like that
sub server_load {
  my $data = shift;
  my (@tmp, $servers);

  push @tmp, {};

  open FILE, $data->{filename}
   or remark('alert', "could not open $data->{filename} for reading: $!")
   and exit 100;

  while (<FILE>) {
    chomp;
    s/^\s+//;
    next if /^#/;

    # treat blank lines as record seperators, if have enough to work with
    if (/^$/ and exists $tmp[-1]->{url}) {
      push @tmp, {};
      next;
    }

    s/\s+$//;

    my ($k, $v) = split /\s+/, $_, 2;
    if (defined $k and defined $v) {
      $tmp[-1]->{$k} = $v;
    } elsif (defined $k and defined URI->new($k)) {

      # convert plain URL into our data format
      push @tmp, {};
      $tmp[-1]->{url} = $k;
      push @tmp, {};
    }
  }
  close FILE;

  for my $server (@tmp) {
    next unless keys %{$server};

    unless (exists $server->{url}) {
      remark('warning', 'no url found: skipping preference data');

      #use Data::Dumper; print Dumper $server;  # DBG
      next;
    }

    unless (exists $server->{name}) {

      # create an abbreviation from URL, use as "name" value until
      # human picks a better one for us
      $server->{name} = URI->new($server->{url})->host_port;

      $prefs_updated = 1;
    }

    if (exists $servers->{$server->{name}}) {
      remark('warning',
        "duplicate server name $server->{name}: skipping new data");
      $prefs_updated = 1;
      next;
    }

    $servers->{$server->{name}} = $server;
  }

  return $servers;
}

# saves pastebot server data
sub server_save {
  my $data = shift;

  open FILE, ">$data->{filename}"
   or remark('alert', "could not open for writing: $!")
   and exit 100;

  for my $name (sort keys %{$data->{data}}) {
    my $server = $data->{data}->{$name};
    for (sort keys %$server) {
      print FILE $_, "\t", $server->{$_}, "\n";
    }
    print FILE "\n";
  }

  close FILE
   or remark('alert', "problem saving to $data->{filename}: $!")
   and exit 100;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  my @tmp;
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam($1))[7] : ( $ENV{HOME} || $ENV{LOGDIR} )
     }ex;
  }
  return wantarray ? @_ : "@_";
}

# generic message handler
sub remark {
  my ($facility, $priority, $message);
  $facility = 'user';

  if (@_ > 1) {
    $priority = shift;
    $message  = "@_";
  } else {
    $priority = 'info';
    $message  = "@_";
  }

  return 1 if exists $opts{'q'} and $priority eq 'info';

  #  if (exists $opts{'l'}) {
  #    if ($opts{'l'} eq "syslog") {
  #      openlog($0, 'cons', $facility);
  #      syslog($priority, $message);
  #      closelog();
  #
  #    } elsif ($opts{'l'} eq "logger") {
  #      system "logger", '-p', $facility . '.' . $priority, '-t', $0, $message;
  #
  #    } else {
  #      die "alert: unknown log handler: ", $opts{'l'};
  #    }
  #
  #  } else {
  warn $priority, ": ", $message, "\n";

  #  }

  return 1;
}

# a generic help blarb
sub help {
  print <<"HELP";
Usage: $0 [global-opts] action [args]

Interacts with pastebot sites.

Options for version $VERSION:
  -h/-?  Display this message

Run perldoc(1) on this script for additional documentation.

HELP
  exit;
}

######################################################################
#
# DOCUMENTATION

=head1 NAME

pbotutil - interacts with pastebot sites

=head1 SYNOPSIS

  $ TODO

=head1 DESCRIPTION

=head2 Overview

Provides a command line interface to pastebot sites: allows posting
to and downloading from such sites.  For more information on
pastebots, see:

http://sourceforge.net/projects/pastebot/

=head2 Normal Usage

  $ pbotutil [global-options] action [args]

See L<"OPTIONS"> for details on the command line switches supported.

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note.

=back

=head1 EXAMPLES

Additional examples/helpfull hints expanding on SYNOPSIS.

=head1 ENVIRONMENT

Any special environement details or warnings?

=head1 FILES

Any important files this script relies on?

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No known bugs.

=head1 TODO

Lots.

=head1 SEE ALSO

perl(1)

=head1 AUTHOR

Jeremy Mates, http://sial.org/contact/

=head1 COPYRIGHT

The author disclaims all copyrights and releases this script into the
public domain.

=head1 VERSION

  $Id$

=cut

