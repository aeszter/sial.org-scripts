#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Interacts with pastebot sites:
# http://sourceforge.net/projects/pastebot/
#
# Run perldoc(1) on this file for additional documentation.

require 5;
use strict;

use Data::Dumper;  # DBG

use File::Basename;
use File::Path;

use URI;

# where preference files are stored
my %pfiles = (servers => '~/.pbotutil/servers');

my $prefs_updated = 0;

my $VERSION;
($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

######################################################################
#
# MAIN

# parse command-line options
use Getopt::Std;
my %opts;
getopts('h?q', \%opts);
help() if exists $opts{'h'} or exists $opts{'?'};

for (keys %pfiles) {
  $pfiles{$_} = tilde_expand($pfiles{$_});

  # create prefs files automagcially
  unless (-e $pfiles{$_}) {
    remark('info', "creating preference file: $pfiles{$_}");
    mkpath(dirname($pfiles{$_}));
    open TOUCH, ">$pfiles{$_}"
     or remark('alert', "could not touch preference file $pfiles{$_}: $!")
     and exit 100;
    close TOUCH;
  }
}

# having no servers may or may not be a good thing
# TODO locking on the prefs file or somthing
my $servers = server_load({filename => $pfiles{servers}});


# TODO this probably needs locking in conjunction with reading above
if ($prefs_updated) {
  server_save({filename => $pfiles{servers}, data => $servers});
}

exit;

######################################################################
#
# SUBROUTINES

sub server_load {
  my $data = shift;
  my (@tmp, $servers);

  push @tmp, {};

  open FILE, $data->{filename}
   or remark('alert', "could not open $data->{filename} for reading: $!")
   and exit 100;

  while (<FILE>) {
    chomp;
    s/^\s+//;
    next if /^#/;

    # treat blank lines as record seperators, if have enough to work with
    if (/^$/ and exists $tmp[-1]->{url}) {
      push @tmp, {};
      next;
    }

    s/\s+$//;

    my ($k, $v) = split /\s+/, $_, 2;
    if (defined $k and defined $v) {
      $tmp[-1]->{$k} = $v;
    } elsif (defined $k and defined URI->new($k)) {

      # convert plain URL into our data format
      push @tmp, {};
      $tmp[-1]->{url} = $k;
      push @tmp, {};
    }
  }
  close FILE;

  for my $server (@tmp) {
    next unless keys %{$server};

    unless (exists $server->{url}) {
      remark('warning', 'no url found: skipping preference data');

      #use Data::Dumper; print Dumper $server;  # DBG
      next;
    }

    unless (exists $server->{name}) {

      # create an abbreviation from URL, use as "name" value until
      # human picks a better one for us
      $server->{name} = URI->new($server->{url})->host_port;

      $prefs_updated = 1;
    }

    if (exists $servers->{$server->{name}}) {
      remark('warning',
        "duplicate server name $server->{name}: skipping new data");
      $prefs_updated = 1;
      next;
    }

    $servers->{$server->{name}} = $server;
  }

  return $servers;
}

# saves pastebot server data
sub server_save {
  my $data = shift;

  open FILE, ">$data->{filename}"
   or remark('alert', "could not open for writing: $!")
   and exit 100;

  for my $name (sort keys %{$data->{data}}) {
    my $server = $data->{data}->{$name};
    for (sort keys %$server) {
      print FILE $_, "\t", $server->{$_}, "\n";
    }
    print FILE "\n";
  }

  close FILE or remark('alert', "problem saving to $data->{filename}: $!") and exit 100;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  my @tmp;
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam($1))[7] : ( $ENV{HOME} || $ENV{LOGDIR} )
     }ex;
  }
  return wantarray ? @_ : "@_";
}

# generic message handler
sub remark {
  my ($facility, $priority, $message);
  $facility = 'user';

  if (@_ > 1) {
    $priority = shift;
    $message  = "@_";
  } else {
    $priority = 'info';
    $message  = "@_";
  }

  return 1 if exists $opts{'q'} and $priority eq 'info';

  #  if (exists $opts{'l'}) {
  #    if ($opts{'l'} eq "syslog") {
  #      openlog($0, 'cons', $facility);
  #      syslog($priority, $message);
  #      closelog();
  #
  #    } elsif ($opts{'l'} eq "logger") {
  #      system "logger", '-p', $facility . '.' . $priority, '-t', $0, $message;
  #
  #    } else {
  #      die "alert: unknown log handler: ", $opts{'l'};
  #    }
  #
  #  } else {
  warn $priority, ": ", $message, "\n";

  #  }

  return 1;
}

# a generic help blarb
sub help {
  print <<"HELP";
Usage: $0 [global-opts] action [args]

Interacts with pastebot sites.

Options for version $VERSION:
  -h/-?  Display this message

Run perldoc(1) on this script for additional documentation.

HELP
  exit;
}

######################################################################
#
# DOCUMENTATION

=head1 NAME

pbotutil - interacts with pastebot sites

=head1 SYNOPSIS

  $ TODO

=head1 DESCRIPTION

=head2 Overview

Provides a command line interface to pastebot sites: allows posting
to and downloading from such sites.  For more information on
pastebots, see:

http://sourceforge.net/projects/pastebot/

=head2 Normal Usage

  $ pbotutil [global-options] action [args]

See L<"OPTIONS"> for details on the command line switches supported.

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note.

=back

=head1 EXAMPLES

Additional examples/helpfull hints expanding on SYNOPSIS.

=head1 ENVIRONMENT

Any special environement details or warnings?

=head1 FILES

Any important files this script relies on?

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No known bugs.

=head1 TODO

Lots.

=head1 SEE ALSO

perl(1)

=head1 AUTHOR

Jeremy Mates, http://sial.org/contact/

=head1 COPYRIGHT

The author disclaims all copyrights and releases this script into the
public domain.

=head1 VERSION

  $Id$

=cut

