#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Prints path information about specified file paths with optional
# warnings about particular user or group problems with specified paths.

use strict;
use Cwd qw(realpath);
use File::Spec;

sub resolve_path;
sub getfileinfo;
sub determine_role;
sub check_access;
sub print_help;

# unix file type mappings
# TODO use "use Fcntl ':mode';" instead?
my %filetype = (
  '0010000' => 'p',
  '0020000' => 'c',
  '0040000' => 'd',
  '0060000' => 'b',
  '0100000' => 'f',
  '0120000' => 'l',
  '0140000' => 's',
  '0160000' => 'w',
);
my %modemap = (
  userr  => 256,
  userw  => 128,
  userx  => 64,
  groupr => 32,
  groupw => 16,
  groupx => 8,
  otherr => 4,
  otherw => 2,
  otherx => 1
);

# NOTE could tighten up per site policy...
my $match_username = qr/\w+/;

my %opts;
for (
  map { $_->[0] }
  sort { $a->[1] <=> $b->[1] } map { [$_, /^[+-]/ ? 0 : 1] } @ARGV
 ) {

  if (/^\+([rwx]+)$/) {
    my $perms = $1;
    for ($perms =~ /(.)/g) { $opts{perms}->{$_} = 1 }
    $opts{constraint} = 1;
    next;
  }

  if (/^-([\w]+)$/) {
    my $opts = $1;
    for ($opts =~ /(.)/g) { $opts{options}->{$_} = 1 }
    next;
  }

  if (/^(user|group)=($match_username)$/) {

    if (exists $opts{role}) {
      warn "notice: ignoring extra role: $_\n";
      next;
    }

    my $what = $1;
    my $who  = $2;

    $opts{role} = determine_role $what, $who;
    $opts{constraint} = 1;
    next;
  }

  if (/^dir=(.+)$/) {
    if (exists $opts{path}) {
      warn "notice: skipping as already have path: $_\n";
      next;
    }
    $opts{path} = resolve_path $1;
    next;
  }

  if (exists $opts{path}) {
    warn "notice: skipping as already have path: $_\n";
    next;
  }
  $opts{path} = resolve_path $_;
}

print_help if exists $opts{options}->{h};

$opts{path} = resolve_path '.' unless exists $opts{path};
die "error: no path to work with\n"
 unless exists $opts{path}
 and defined $opts{path};

$opts{constraint} = 1
 if exists $opts{options}->{u}
 or exists $opts{options}->{g}
 or exists $opts{options}->{R};

# verbose list by default unless checking something specific
$opts{options}->{l} = 1 unless exists $opts{constraint};

# use current user if constrained and no user set
if (exists $opts{constraint} and not exists $opts{role}) {
  if (exists $opts{options}->{g}) {
    $opts{role} = determine_role 'group', split / /,
     exists $opts{options}->{R} ? $( : $);
  } else {
    $opts{role} = determine_role 'user', exists $opts{options}->{R} ? $< : $>;
  }
}
if (exists $opts{constraint} and not exists $opts{perms}) {
  $opts{perms}->{r} = 1;
}

# fix perms hash to use array for easier subsequent work
$opts{perms} = [sort keys %{$opts{perms}}];

my @pathbits = File::Spec->splitdir($opts{path});
die "error: unable to split realpath: $opts{path}" unless @pathbits;

my $current = '';
for my $i (0 .. $#pathbits) {
  $current = File::Spec->catdir($current, $pathbits[$i]);
  my $filedata = getfileinfo $current;

  unless ($filedata) {
    die "error: no data about $current\n";
  }

  # TODO means of supplying output fields and their order?
  if (exists $opts{options}->{l}) {
    print join " ", map $filedata->{$_},
     qw(type unix_mode_octal unix_user unix_group name);
    print ' -> ', $filedata->{link} if exists $filedata->{link};
    print "\n";
  }

  if (exists $opts{constraint}) {
    check_access $filedata, $i != $#pathbits ? [qw(r x)] : $opts{perms};
  }
}

sub resolve_path {
  my $potential = shift;
  if (exists $opts{options}->{r}) {
    my $tmp = realpath($potential);
    defined $tmp
     ? return $tmp
     : warn "warning: could not convert to real path: $potential\n";
  }
  File::Spec->rel2abs($potential);
}

# accepts user|group, and a username/groupname/uid/gid and figures out
# name, id, and type details.  Returns array of hashrefs.
sub determine_role {
  my $what = shift;
  my @who  = @_;

  my (@userdata, $type, %seen);

  my $function = 'get';
  if ($what eq 'group') {
    $function .= 'gr';
    $type = 'group';
  } else {
    $function .= 'pw';
    $type = 'user';
  }

  for my $who (@who) {
    my %userdata;
    if ($who =~ /^\d+$/) {
      $function .= $type eq 'group' ? 'g' : 'u';
      $function .= 'id';

      next if exists $seen{"$type.$who"};

      $userdata{name} = eval qq{$function("$who")};
      unless (defined $userdata{name}) {

        # TODO figure out how unix deals with [gu]id that does not exist..
        # treat in "other" category??
        warn "warning: no data from $function $who\n";
        $userdata{name} = $who;
      }
      $userdata{id}       = $who;
      $userdata{type}     = $type;
      $seen{"$type.$who"} = 1;
    } else {
      $function .= 'nam';
      $userdata{id} = eval qq{$function("$who")};
      unless (defined $userdata{id}) {
        die "error: could not determine id from $function $who\n";
      }
      next if exists $seen{"$type.$userdata{id}"};
      $userdata{name}              = $who;
      $userdata{type}              = $type;
      $seen{"$type.$userdata{id}"} = 1;
    }
    push @userdata, \%userdata;
  }

  if ($type eq 'user') {
    my $id = (getpwuid $userdata[0]->{id})[3];
    unless (exists $seen{"group.$id"}) {

      my $name = getgrgid $id;
      push @userdata,
       {
        type => 'group',
        id   => $id,
        name => $name
       };
      $seen{"group.$id"} = 1;
    }

    # TODO iterate groups for which user has membership in...
    while (my ($name, $pw, $gid, $members) = getgrent) {
      if (grep { $_ eq $userdata[0]->{name} } split " ", $members) {
        unless (exists $seen{"group.$gid"}) {
          push @userdata,
           {
            type => 'group',
            id   => $gid,
            name => $name
           };
          $seen{"group.$gid"} = 1;
        }
      }
    }
  }

  return \@userdata;
}

# returns various information about specified file in hash reference
sub getfileinfo {
  my $file = shift;

  my %filedata;
  $filedata{name} = $file;
  @filedata{qw(unix_mode unix_uid unix_gid)} = (lstat $file)[2, 4, 5];

  return unless defined $filedata{unix_mode};

  # TODO means of converting unix mode to drwx------ format?

  $filedata{unix_mode_octal} = sprintf "%04o", $filedata{unix_mode} & 07777;

  $filedata{type} = $filetype{sprintf "%07o", $filedata{unix_mode} & 0170000};
  $filedata{link} = readlink $file if $filedata{type} eq 'l';

  $filedata{unix_user}  = getpwuid $filedata{unix_uid} || $filedata{unix_uid};
  $filedata{unix_group} = getgrgid $filedata{unix_gid} || $filedata{unix_gid};

  return \%filedata;
}

sub check_access {
  my $filedata = shift;
  my $perms    = shift;

  for my $role (@{$opts{role}}) {
    if ($role->{name} eq $filedata->{"unix_" . $role->{type}}) {

      my @fails;
      for my $bit (@$perms) {
        push @fails, $bit
         unless $filedata->{unix_mode} & $modemap{$role->{type} . $bit};
      }
      print $role->{type}, ' ', $role->{name}, ' +', join('', @fails),
       ' fails on ', $filedata->{type}, ' ', $filedata->{name}, "\n"
       if @fails;

      # unix, once gets match on user or group, stops looking at subsequent
      return;
    }
  }

  # if drop off here without being restricted, need to check other access
  my @fails;
  for my $bit (@$perms) {
    push @fails, $bit unless $filedata->{unix_mode} & $modemap{'other' . $bit};
  }
  print 'other', ' +', join('', @fails), ' fails on ', $filedata->{type}, ' ',
   $filedata->{name}, "\n"
   if @fails;
}

# usage notes
sub print_help {
  print <<"HELP";
$0 takes the following arguments in any order:

  directory - single directory to parse (default current directory).
    -r  Attempt to use realpath() of directory.

  Use dir=directory if directory name conflicts with option.

  Constraints (uses current user/group if (user|group)= is missing):

  +r|+w|+x  - check whether read, write, or execute access possible.
  user=???  - specify user to limit to (default: current user).
  group=??? - specify group to limit to (default: current group).

  -u    Use current user if constraining.
  -g    Use currrent group(s) if constraining.
  -R    Use real user/group instead of effective.

  -h    Print these notes.
  -l    Verbose list of path to file (default if nothing else).

HELP
  exit 1;
}
