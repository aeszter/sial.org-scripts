#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Prints path information about specified file paths with optional
# warnings about particular user or group problems with specified paths.

use strict;
use Cwd qw(realpath);
use File::Spec;

sub getfileinfo;
sub determine_role;

# unix file type mappings
# TODO use "use Fcntl ':mode';" instead?
my %filetype = (
  '0010000' => 'p',
  '0020000' => 'c',
  '0040000' => 'd',
  '0060000' => 'b',
  '0100000' => 'f',
  '0120000' => 'l',
  '0140000' => 's',
  '0160000' => 'w',
);

# NOTE could tighten up per site policy...
my $match_username = qr/\w+/;

my %opts;
for (@ARGV) {
  if (/^\+([rwx]+)$/) {
    my $perms = $1;
    for ($perms =~ /(.)/g) { $opts{perms}->{$_} = 1 }
    $opts{constraint} = 1;
    next;
  }

  if (/^-([\w]+)$/) {
    my $opts = $1;
    for ($opts =~ /(.)/g) { $opts{options}->{$_} = 1 }
    next;
  }

  if (/^(user|group)=($match_username)$/) {

    if (exists $opts{role}) {
      warn "warning: ignoring extra role: $_\n";
      next;
    }

    my $what = $1;
    my $who  = $2;

    $opts{role} = determine_role $what, $who;
    $opts{constraint} = 1;
    next;
  }

  if (my $tmp = realpath $_) {
    if (exists $opts{path}) {
      warn "warning: skipping as already have path: $_\n";
      next;
    }
    $opts{path} = $tmp;
  } else {
    warn "warning: skipping as not real path: $_\n";
  }
}

$opts{path} = realpath '.' unless exists $opts{path};
die "error: no path to work with\n"
 unless exists $opts{path}
 and defined $opts{path};

# verbose list by default unless checking something specific
$opts{options}->{l} = 1 unless exists $opts{constraint};

# use current user if constrained and no user set
if (exists $opts{constraint} and not exists $opts{role}) {
  my $what = exists $opts{options}->{g} ? 'group' : 'user';
  my $who  = exists $opts{options}->{R} ? $<      : $>;
  $opts{role} = determine_role $what, $who;
}

# DBG
#use Data::Dumper;
#print Dumper \%opts;

my @pathbits = File::Spec->splitdir($opts{path});
die "error: unable to split realpath: $opts{path}" unless @pathbits;

my $current = '';
for my $filename (@pathbits) {
  $current = File::Spec->catdir($current, $filename);
  my $filedata = getfileinfo $current;

  unless ($filedata) {
    die "error: no data about $current\n";
  }

  # TODO means of supplying output fields and their order?
  if (exists $opts{options}->{l}) {
    print join " ", map $filedata->{$_},
     qw(type unix_mode_octal unix_user unix_group name);
    print ' -> ', $filedata->{link} if exists $filedata->{link};
    print "\n";
  }
}

# accepts user|group, and a username/groupname/uid/gid and figures the
# exact details out.  Returns hashref with details.
sub determine_role {
  my $what = shift;
  my $who  = shift;

  my %userdata;

  my $function = 'get';
  if ($what eq 'group') {
    $function .= 'gr';
    $userdata{type} = 'group';
  } else {
    $function .= 'pw';
    $userdata{type} = 'user';
  }

  if ($who =~ /^\d+$/) {
    $function .= $userdata{type} eq 'group' ? 'g' : 'u';
    $function .= 'id';
    unless ($userdata{name} = eval "$function $who") {

      # TODO figure out how unix deals with [gu]id that does not exist..
      # treat in "other" category??
      warn "warning: no data from $function $who\n";
      $userdata{name} = $who;
    }
    $userdata{id} = $who;
  } else {
    $function .= 'nam';
    unless ($userdata{id} = eval "$function $who") {
      die "error: could not determine id from $function $who\n";
    }
    $userdata{name} = $who;
  }

  return \%userdata;
}

# returns various information about specified file in hash reference
sub getfileinfo {
  my $file = shift;

  my %filedata;
  $filedata{name} = $file;
  @filedata{qw(unix_mode unix_uid unix_gid)} = (lstat $file)[2, 4, 5];

  return unless defined $filedata{unix_mode};

  # TODO means of converting unix mode to drwx------ format?

  $filedata{unix_mode_octal} = sprintf "%04o", $filedata{unix_mode} & 07777;

  $filedata{type} = $filetype{sprintf "%07o", $filedata{unix_mode} & 0170000};
  $filedata{link} = readlink $file if $filedata{type} eq 'l';

  $filedata{unix_user}  = getpwuid $filedata{unix_uid} || $filedata{unix_uid};
  $filedata{unix_group} = getgrgid $filedata{unix_gid} || $filedata{unix_gid};

  return \%filedata;
}
