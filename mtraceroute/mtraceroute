#!/usr/bin/perl -w
#
# $Id$
#
# Copyright (c) 2000, Jeremy A. Mates.  All Rights Reserved.
#
# Use perldoc on this file for documentation/licensing information.
#
######################################################################
#
# REQUIREMENTS

require 5.005;

use strict;
#use warnings;
#no warnings qw(uninitialized);

######################################################################
#
# MODULES

use Carp;
use Getopt::Std;

######################################################################
#
# VARIABLES

my $VERSION; ($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

my (%opts, %data, %stats, $traceroute);

# change to suit your needs
$traceroute = '/usr/sbin/traceroute';

######################################################################
#
# MAIN

# parse command-line options
getopts('h?', \%opts);

help() if exists $opts{'h'} or exists $opts{'?'};

# read from STDIN if no args left
chomp(@ARGV = <STDIN>) unless @ARGV;

# and flag the help text if nothing from STDIN
help() unless @ARGV;

# reference on the data structure used herein:
# %data = (
# 'hostname' => {
#   array of anon hashes holding traceroute output...
#   array index is -1 the hop, hash holds 'ip' 'hostname' 
#   and then 'times' => array of probe times
# in case of '* * *' timeout, usual ip/host/times will be undef,
# so be sure to check for it!

# ref on stats, which holds additional (global) info...
# %stats = (
# 'hostname' => {
#    'timeouts' = count of number of timeouts (* * *) along path
#    'maxhops' = total number of hops to target host

# assume incoming data is wave of hosts/ip addresses to traceroute to
foreach my $host (@ARGV) {
    unless (open (TRACE, "$traceroute $host 2>/dev/null |")) {
	die "Problem with traceroute on $host: $!\n";
    } else {
	$stats{$host}->{'timeouts'} = 0;

	while (<TRACE>) {
	    print;		# DBG

	    # head off timeouts at the pass, otherwise rip by regex
	    if (m/^\s*\d+\s+\* \* \*$/) {
		push(@{$data{$host}}, undef);
		$stats{$host}->{'timeouts'}++;

	    } elsif (m/^\s*\d+[ *]+    # optional leading whitespace & index
		     (\S+)\s+	       # hostname   $1
		     \(([^\)]+)\)\s+   # ip address (inside ()'s)   $2
		     (.*?)$/x	       # the probe times $3
		     ) {

		# extract probe times hackishly
		my (@times) = split /[^0-9.]+/, $3;

		# catch triple failed probes; mean/stddev don't like
		# null arrays, as it turns out...
		unless (@times) {
		    push(@times, -1);
		}

		print "                                         ", join("   ", @times), "\n"; # DBG

		# righty, form up data thingy...
		push(@{$data{$host}}, {
		    'ip' => $2,
		    'hostname' => $1,
		    'times'    => \@times,
		    'mean'     => mean(\@times),
		    'stddev'   => standard_deviation_data(\@times),
		});
	    }			# elsif
	}			# while

	close (TRACE);

	# now a good time to store some stats...
	if (defined $data{$host}) {
	    $stats{$host}->{'maxhops'} = scalar @{$data{$host}};
	}

    }				# else
}

# simple display until I can figure out better stuff to do with
# the data...
foreach my $host (@ARGV) {
    print $stats{$host}->{'maxhops'}, " to host ", $host;
    if ($stats{$host}->{'timeouts'} > 0) {
	print " errors ", $stats{$host}->{'timeouts'};
    } else {
	print " no errors";
    }
    print "\n";
    
    # and let's look at some specific stuff
#    foreach my $info (@{$data{$host}}) {
#	print $info->{'mean'}, "\t", $info->{'stddev'}, "\n";
#    }
}

exit;

######################################################################
#
# SUBROUTINES

# $sd = standard_deviation_data(\@array) computes the standard
# deviation of an array of numbers.
#
sub standard_deviation_data {
    my $arrayref = shift;
    my $mean = mean($arrayref);
    return sqrt( mean( [map $_ ** 2, @$arrayref] ) - ($mean ** 2) );
}

# $mean = mean(\@array) computes the mean of an array of numbers.
#
sub mean {
    my ($arrayref) = shift;
    my $result;
    foreach (@$arrayref) { $result += $_ }
    return $result / @$arrayref;
}

# a generic help blarb
sub help {
    print <<"HELP";
Usage: $0 [options] host1 [host2 .. hostN]

A mass tracerouter that summarizes the results.

Options:
  -h/-?  Display this message

Run perldoc on this script for more documentation.

HELP
    exit;
}

__END__

######################################################################
#
# DOCUMENTATION

=head1 NAME

mtraceroute.pl - a script to summarize traceroutes.

$Id$

=head1 SYNOPSIS

  $ mtraceroute example.com example.org

Or ride them in on STDIN:

  $ cat list_of_hosts | mtraceroute.pl

=head1 DESCRIPTION

This script serves the purpose of doing many traceroutes, and storing
the results for later comparison, e.g. to find the nearest host among
a host of mirrors.

=head1 USAGE

mtraceroute.pl [options] host1 [host2 .. hostN]

Options are detailed below.  The list of hosts can either be supplied
on the command line (e.g. with xargs(1)), or passed in on STDIN(3).

The script does no error checking on the supplied data, which should
consist of hostnames or ip addresses to be passed directly to
traceroute(8).

=head1 OPTIONS

The only option is help right now, which refers you here. :)

=head1 TODO

Variety of output formats, e.g. dump-to-perl-data-structure or perhaps
XML output.

Better way specifying traceroute/path to and also means of passing
command line switches to said program.

=head1 BUGS

Please send any bug reports (preferably with a patch) to:

jmates@sial.org

=head1 SEE ALSO

perl(1), traceroute(8)

=head1 AUTHOR

Jeremy A. Mates, jmates@sial.org

=head1 COPYRIGHT

Copyright (c) 2000, Jeremy A. Mates.  All Rights Reserved.

This file is licensed under the terms of the Artistic License:

http://www.sial.org/artistic_license.txt

=cut
