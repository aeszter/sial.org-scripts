#!/usr/bin/perl -wT
#
# $Id$
#
# Copyright (c) 2002, Jeremy A. Mates.  This script is free software;
# you can redistribute it and/or modify it under the same terms as
# Perl itself.
#
# Run perldoc(1) on this file for additional documentation.
#
######################################################################
#
# REQUIREMENTS

require 5;

use strict;

# clean up env for taint mode ("perldoc perlsec" for more information)
sub BEGIN {
  delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
  $ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
}

######################################################################
#
# MODULES

use Carp;         # better error reporting
use Getopt::Std;  # command line option processing

use Digest::MD5 qw(md5);  # Perl interface to the MD5 Algorithm

######################################################################
#
# VARIABLES

my $VERSION;
($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

my (%opts);

# path to authorized_keys file.  OpenSSH >= 3.0 should merge old
# authorized_keys2 files into authorized_keys.
my $auth_key_file       = "~/.ssh/authorized_keys";
my $auth_key_file_chars = '[\w\s.~/-]';

# registered commands
my %command = (
  'list'   => \&do_list,
  'write'  => \&do_write,
  'delete' => \&do_delete,
);

#  'get'     => \&do_get,
#  'put'     => \&do_put,

######################################################################
#
# MAIN

# parse command-line options
getopts('h?f:ai', \%opts);

help() if exists $opts{'h'} or exists $opts{'?'};

$auth_key_file = $opts{'f'} if exists $opts{'f'};

# do ~ expansion on filename
$auth_key_file =~ s{ ^ ~ ( [^/]* ) }
                    { $1 ? (getpwnam($1))[7]
                          : ( $ENV{HOME} || $ENV{LOGDIR}
                              || (getpwuid($>))[7]
                              )
                          }ex;

# untaint filename
if ($auth_key_file =~ m,^([\w\s.~/-]+)$,) {
  $auth_key_file = $1;
} else {
  die "Invalid characters in filename.\n";
}

# read in keys
my $data = extract($auth_key_file);

# clear out arguments unless we're reading commands from there
@ARGV = () unless exists $opts{'a'};

# read commands from STDIN if specified
if (exists $opts{'i'}) {
  my @tmp;
  chomp(@tmp = <STDIN>);
  push @ARGV, @tmp;
}

# and flag the help text if nothing from STDIN
help() unless @ARGV;

# look for commands and deal with them
for (@ARGV) {
  next if m/^#/ or m/^\s*$/;

  # TODO: -a will not work with following, as tricky to get
  # command line arguments with tabs in them on unix...
  my @work = split /\t/;
  my $cmd  = shift @work;

  unless (exists $command{$cmd}) {
    warn "Warning: skipping unknown command: $cmd\n";
    next;
  }

  $command{$cmd}(@work);
}

exit;

######################################################################
#
# SUBROUTINES

# shows some info about known keys
sub do_list {
  for (sort keys %$data) {
    print join ("\t",
      $data->{$_}->{'hash'},
      $data->{$_}->{'type'},
      $data->{$_}->{'comment'}),
     "\n";
  }
}

# merges keys into auth_key_file
sub do_write {
  open KFILE, ">$auth_key_file"
   or die "Could not write authorized key file: $!\n";

  for (sort keys %$data) {
    print KFILE $data->{$_}->{'key'}, "\n";
  }

  close KFILE;
}

sub do_delete {

}

# pulls auth_key_file into individual files for better managablity
# takes no arguments, returns a data structure of keys
sub extract {
  my $auth_key_file = shift;
  my %data;

  open KFILE, $auth_key_file
   or die "Error: could not open authorized key file: $!\n";

  while (<KFILE>) {

    # see sshd(8) for expected format of auth_key_file
    next if m/^#/ or m/^\s*$/;

    my (%values, @options);

    # TODO: improve parser to get around boundary cases!
    # e.g.: command="mumble ssh-rsa AAAA.... zot" ssh-rsa AAAA....
    # or even: ssh-rsa  AAAA...

    # try to pull apart key so we can do a checksum on the
    # important bits (i.e. not the optional option and comment fields)
    my @elements = split /\s/;
    for my $i (0 .. $#elements) {

      if (  $elements[$i] =~ m/^ssh-(?:rsa|dss)$/
        and $elements[$i + 1] =~ m/^AAAA/) {

        $values{'type'} = ($elements[$i] =~ m/rsa$/) ? 'rsa' : 'dsa';
        $values{'goodbit'} = join " ", @elements[$i .. $i + 1];
        $values{'comment'} = join " ", @elements[$i + 2 .. $#elements];

        last;

        } elsif ($elements[$i] =~ m/^\d+$/
        and $elements[$i + 1] =~ m/^\d+$/
        and $elements[$i + 2] =~ m/^\d+$/) {

        $values{'type'}    = 'rsa1';
        $values{'goodbit'} = join " ", @elements[$i .. $i + 2];
        $values{'comment'} = join " ", @elements[$i + 3 .. $#elements];

        last;
      }

      push @options, $elements[$i];
    }

    unless (exists $values{'goodbit'}) {
      warn "Could not parse key from: $_\n";
      next;
    }

    $values{'hash'} = sprintf "%08x", unpack "N", md5($values{'goodbit'});
    $values{'options'} = "@options";
    $values{'key'}     = $_;

    $data{$values{'hash'}} = \%values;
  }

  close KFILE;

  return \%data;
}

# a generic help blarb
sub help {
  print <<"HELP";
Usage: $0 [opts]

Manages an OpenSSH authorized_keys file.

Options for version $VERSION:
  -h/-?  Display this message

  -f ff  Use specified authorized_keys file instead of default.

  -a     Allow commands on the command line.
  -i     Allow commands on STDIN.

Run perldoc(1) on this script for additional documentation.

HELP
  exit;
}

######################################################################
#
# DOCUMENTATION

=head1 NAME

ssh-authkey-manage.pl - manages an OpenSSH authorized_keys file

=head1 SYNOPSIS

Get a listing of keys in the default authorized_keys file:

  $ ssh-authkey-manage.pl -a list

=head1 DESCRIPTION

=head2 Overview

Provides a scriptable means of listing, altering, and deleting keys
out of an OpenSSH C<~/.ssh/authorized_keys> file.

=head2 Normal Usage

  $ ssh-authkey-manage.pl [options] [commands]

See L<"COMMANDS"> for details on the command syntax.

See L<"OPTIONS"> for details on the command line switches supported.

=head1 COMMANDS

Commands allow scriptable interaction with the authorized_keys file. 
Multiple commands may be supplied on either the command line or on
STDIN.  Current commands are:

=over 4

=item B<list>

Shows what temporary keyfiles are available, plus some general data
about the public key in question.

=item B<write>

Overwrites the authorized_keys file with the keys in memory, if any.

=back

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note about the script.

=item B<-f> I<auth_key_file>

Use the specified authorized_keys file instead of the default.

=item B<-a>

Allow commands on the command line.

=item B<-i>

Allow commands on STDIN.  If nothing is found on STDIN, the script
will stall, waiting for input.

One (or both) of B<-a> or B<-i> must be specified for the script to do
anything.

=back

=head1 EXAMPLES

Additional examples/helpfull hints expanding on SYNOPSIS.

=head1 ENVIRONMENT

Requires an up-to-date version of OpenSSH; ancient versions may not
have the B<-l> and B<-f> options required for ssh-keygen(1) to list
all keytypes.

Developed with OpenSSH 3.4 on Mac OS X (10.1.5) with perl 5.8.

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://www.sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

Commands expecting arguments use tabs to separate the parameters. 
Tabs are difficult to input on the command line, so STDIN is advised
for commands that require arguments.

Comments or blank lines in the authorized_keys file will be deleted
following an extract-merge cycle.

=head1 TODO

A means to lock the .ssh directory to only allow one invocation of
this script to run, or on auth_keys_file.

Ability to alter comment on specified keys?

=head1 SEE ALSO

perl(1), ssh-keygen(1)

=head1 AUTHOR

Jeremy A. Mates, http://www.sial.org/contact/

=head1 COPYRIGHT

Copyright (c) 2002, Jeremy A. Mates.  This script is free software;
you can redistribute it and/or modify it under the same terms as Perl
itself.

=head1 VERSION

  $Id$

=cut
