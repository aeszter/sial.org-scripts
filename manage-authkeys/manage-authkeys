#!/usr/bin/perl -wT
#
# $Id$
#
# Copyright (c) 2002, Jeremy A. Mates.  This script is free software;
# you can redistribute it and/or modify it under the same terms as
# Perl itself.
#
# Run perldoc(1) on this file for additional documentation.
#
######################################################################
#
# REQUIREMENTS

require 5;

use strict;

# clean up env for taint mode ("perldoc perlsec" for more information)
sub BEGIN {
  delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
  $ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
}

######################################################################
#
# MODULES

use Carp;         # better error reporting
use Getopt::Std;  # command line option processing

use Digest::MD5 qw(md5);  # Perl interface to the MD5 Algorithm

#use Cwd;                 # working directory operations
#use File::Temp;          # safe temporary files
use File::Basename;       # parses file specifications

######################################################################
#
# VARIABLES

my $VERSION;
($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

my (%opts);

# path to authorized_keys file.  OpenSSH >= 3.0 should merge old
# authorized_keys2 files into authorized_keys.
my $auth_key_file       = "~/.ssh/authorized_keys";
my $auth_key_file_chars = '[\w\s.~/-]';

my $temp_key_suffix = '.akey';

# what to use as a working directory
my $auth_key_dir;

# registered commands
my %command = (
  'list'    => \&do_list,
  'extract' => \&do_extract,
  'clean'   => \&do_clean,
  'merge'   => \&do_merge,
  'delete'  => \&do_delete,
  'get'     => \&do_get,
  'put'     => \&do_put,
);

######################################################################
#
# MAIN

# parse command-line options
getopts('h?f:ai', \%opts);

help() if exists $opts{'h'} or exists $opts{'?'};

$auth_key_file = $opts{'f'} if exists $opts{'f'};

# do ~ expansion on filename
$auth_key_file =~ s{ ^ ~ ( [^/]* ) }
                    { $1 ? (getpwnam($1))[7]
                          : ( $ENV{HOME} || $ENV{LOGDIR}
                              || (getpwuid($>))[7]
                              )
                          }ex;

# untaint filename
if ($auth_key_file =~ m,^([\w\s.~/-]+)$,) {
  $auth_key_file = $1;
} else {
  die "Invalid characters in filename.\n";
}

# set working directory to that of one containing auth_key_file
$auth_key_dir = dirname($auth_key_file);

chdir $auth_key_dir or die "Error: could not chdir to $auth_key_dir: $!\n";

# clear out arguments unless we're reading commands from there
@ARGV = () unless exists $opts{'a'};

# read commands from STDIN if specified
if (exists $opts{'i'}) {
  my @tmp;
  chomp(@tmp = <STDIN>);
  push @ARGV, @tmp;
}

# and flag the help text if nothing from STDIN
help() unless @ARGV;

# look for commands and deal with them
for (@ARGV) {
  next if m/^#/ or m/^\s*$/;

  # TODO: -a will not work with following, as tricky to get
  # command line arguments with tabs in them on unix...
  my @work = split /\t/;
  my $cmd  = shift @work;

  unless (exists $command{$cmd}) {
    warn "Warning: skipping unknown command: $cmd\n";
    next;
  }

  $command{$cmd}(@work);
}

exit;

######################################################################
#
# SUBROUTINES

# shows what temporary keyfiles are available
sub do_list {
  my @files = <*$temp_key_suffix>;
  for (@files) {
    my $hash;
    ($hash = $_) =~ s/$temp_key_suffix$//;
    print $hash, "\n";
  }
}

# pulls auth_key_file into individual files for better managablity
# takes no arguments, returns true/false depending on result
sub do_extract {
  open KFILE, $auth_key_file
   or die "Error: could not open authorized key file: $!\n";

  while (<KFILE>) {

    # see sshd(8) for expected format of auth_key_file
    next if m/^#/ or m/^\s*$/;

    # TODO: improve parser to get around boundary cases!
    # e.g.: command="mumble ssh-rsa AAAA...." ssh-rsa AAAA....

    # try to pull apart key so we can do a checksum on the
    # important bits (i.e. not the optional option and comment fields)
    my $goodbits;

    my @elements = split /\s/;
    for (0 .. $#elements) {
      if ($elements[$_] =~ m/^(?:ssh-(?:rsa|dss)|\d+)$/) {
        splice @elements, 0, $_;
        last;
      }
    }

    die "Error: out of elements" unless @elements;

    if ($elements[0] =~ m/^ssh-(?:rsa|dss)$/) {
      $goodbits = join " ", @elements[0 .. 1];
    } else {
      $goodbits = join " ", @elements[0 .. 2];
    }

    my $hash = sprintf "%08x", unpack "N", md5($goodbits);
    $hash =~ /([A-Za-z0-9]+)/;
    $hash = $1;
    die "Error: not enough characters in hash" if length $hash < 8;

    # save key to external file
    open OUT, ">$hash$temp_key_suffix"
     or die "Could not write keyfile $hash$temp_key_suffix: $!\n";
    print OUT $_;
    close OUT;

  }

  close KFILE;
}

# merges temporary key files (if any) into auth_key_file
sub do_merge {
  my @files = <*$temp_key_suffix>;
  if (@files) {
    open KFILE, ">$auth_key_file"
     or die "Could not write authorized key file: $!\n";

    for (@files) {
      open FILE, $_ or die "Could not read keyfile $_: $!\n";
      print KFILE while <FILE>;
      close FILE;
    }

    close KFILE;
  }
}

# removes any temporary key files
sub do_clean {
  unlink <*$temp_key_suffix>;
}

# a generic help blarb
sub help {
  print <<"HELP";
Usage: $0 [opts]

Manages an OpenSSH authorized_keys file.

Options for version $VERSION:
  -h/-?  Display this message

  -f ff  Use specified authorized_keys file.

  -a     Allow commands on the command line.
  -i     Allow commands on STDIN.

Run perldoc(1) on this script for additional documentation.

HELP
  exit;
}

######################################################################
#
# DOCUMENTATION

=head1 NAME

ssh-authkey-manage.pl - manages an OpenSSH authorized_keys file

=head1 SYNOPSIS

Quick usage notes here.

=head1 DESCRIPTION

=head2 Overview

Provides a scriptable means of listing, altering, and deleting keys
out of an OpenSSH C<~/.ssh/authorized_keys> file.

=head2 Normal Usage

  $ ssh-authkey-manage.pl [options] [commands]

See L<"COMMANDS"> for details on the command syntax.

See L<"OPTIONS"> for details on the command line switches supported.

=head1 COMMANDS

Commands allow scriptable interaction with the authorized_keys file. 
Multiple commands may be supplied on either the command line or on
STDIN.  Current commands are:

=over 4

=item B<extract>

Attempts to pull apart the authorized_keys file into individual
keyfiles suitable for operation on by other commands.  It is advisable
to run this command before any others to make sure the temporary files
are up-to-date.

=item B<list>

Shows what temporary keyfiles are available.

=item B<merge>

Overwrites the authorized_keys file with the contents of the temporary
keyfiles, if any.

=item B<clean>

Removes any temporary keyfiles.

=back

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note about the script.

=item B<-f> I<auth_key_file>

Use the specified authorized_keys file instead of the default.

=item B<-a>

Allow commands on the command line.

=item B<-i>

Allow commands on STDIN.  If nothing is found on STDIN, the script
will stall, waiting for input.

One (or both) of B<-a> or B<-i> must be specified for the script to do
anything.

=back

=head1 EXAMPLES

Additional examples/helpfull hints expanding on SYNOPSIS.

=head1 ENVIRONMENT

Requires an up-to-date version of OpenSSH; ancient versions may not
have the B<-l> and B<-f> options required for ssh-keygen(1) to list
all keytypes.

Developed with OpenSSH 3.4 on Mac OS X with perl 5.8.

=head1 FILES

Any important files this script relies on?

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://www.sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No known bugs.

=head1 SEE ALSO

perl(1), ssh-keygen(1)

=head1 AUTHOR

Jeremy A. Mates, http://www.sial.org/contact/

=head1 COPYRIGHT

Copyright (c) 2002, Jeremy A. Mates.  This script is free software;
you can redistribute it and/or modify it under the same terms as Perl
itself.

=head1 VERSION

  $Id$

=cut
