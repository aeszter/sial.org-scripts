#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Script to handle opening of various archive formats.

use strict;
use File::Basename qw(fileparse);

# what to consider as a filename suffix seperator (all OS I've seen use
# a period, but you never know...)
my $suffix_char = '.';
my $suffix_re   = qr/\./;

# default class to use
my $class = 'expand';

my $prefs_file = $ENV{'OSMCONF'} || '~/.osm/prefs';
my $data = load_prefs(tilde_expand($prefs_file));

# TODO need option to dip into archive (read it) to check for possible
# security issues (like ../../ attacks and the like)?

die "TODO usage notes\n" unless @ARGV;

for my $file (@ARGV) {
  # TODO file not existing increases odds it is URL, or bogus...
  #  unless (-e $file) {
  #    remark('notice', 'skipping as does not exist', { file => $file });
  #    next;
  #  }

  # TODO might also need to consider whether thing passed in is a URL,
  # in which case it would need to be downloaded first...
 ATTEMPT: for my $suffix ( get_suffixes($file), '*' ) {
    if ( exists $data->{'_suffixmap'}->{$class}->{$suffix} ) {
      for my $index ( @{ $data->{'_suffixmap'}->{$class}->{$suffix} } ) {
        # TODO also need to pass in whether to use quiet, verbose, etc...
        last ATTEMPT
         if handle_file( { file => $file }, $data->{$class}->[$index] );
      }
    }
  }
}

sub handle_file {
  my $param  = shift;
  my $config = shift;

  my %tmp = ( %$config, %$param );

  # TODO these must be user-specified...
  delete @tmp{qw(verbose destopt preserve)};

  # TODO what about %{file} versus %{files} ? save for future version?
  $tmp{'exec'} =~ s/%{(\w+)}/$tmp{$1}||''/ge;
  $tmp{'exec'} = [ split /\s+/, $tmp{'exec'} ];

  system( @{ $tmp{'exec'} } ) == 0
   or remark(
    'warning',
    'bad exit status',
    { errno => $!, map { $_ => $tmp{$_} } qw(file name class) }
   )
   and return 0;

  return 1;
}

# given filename such as "foo.zip" or "bar.tar.gz" returns list of
# suffixes, longest first (e.g. qw(zip) or qw(tar.gz gz) for the
# previous example filenames).
sub get_suffixes {
  my $file = shift;

  my @portions = split /$suffix_re/, fileparse($file);
  return unless @portions > 1;

  return ( $portions[-1] ) if @portions == 2;

  my @suffixes;
  local $" = $suffix_char;
  for my $i ( 1 .. $#portions ) {
    push @suffixes, "@portions[$i..$#portions]"
  }
  return @suffixes;
}

sub load_prefs {
  my $file = shift;

  open my $fh, "< $file"
   or remark( 'error', 'could not load preferences', { file => $file } )
   and exit 101;

  my %data;

  my %tmp = load_defaults();

  while (<$fh>) {
    s/^\s+//;
    next if /^#/;
    chomp;

    if (/^$/) {
      if ( exists $tmp{'name'} ) {
        if ( exists $tmp{'suffix'} ) {
          $tmp{'suffix'} = [ map { s/^\.//; $_ } split / /, $tmp{'suffix'} ];
        }

        push @{ $data{ $tmp{'class'} } }, {%tmp};

        if ( exists $tmp{'suffix'} ) {
          for my $suffix ( @{ $tmp{'suffix'} } ) {
            push @{ $data{'_suffixmap'}->{ $tmp{'class'} }->{$suffix} },
             $#{ $data{ $tmp{'class'} } };
          }
        }

        %tmp = load_defaults();
      }
      next;
    }

    s/\s+$//;

    my ( $k, $v ) = split /\s+/, $_, 2;
    unless ( defined $k and $k =~ /^[\w.-]+$/ and defined $v ) {
      remark(
        'warning',
        'skipping invalid data',
        { file => 'prefs', line => $. }
      );
      next;
    }
    $tmp{$k} = $v;
  }

  # TODO somehow need to sort the suffix list by priority, or ideally
  # sort the records by priority, then generate the suffixmap references...
  #
  # or skip priorities, and use the order the item appears in the prefs
  # file as the priority?
  #
  # maybe also check on how XSLT does priority on templates for ideas

  return \%data;
}

sub load_defaults {
  my %defaults = (
    class    => 'expand',
    priority => 100
  );
  return %defaults;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam($1))[7] : ( $ENV{'HOME'} || $ENV{'LOGDIR'} )
     }ex;
  }
  return wantarray ? @_ : "@_";
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}
