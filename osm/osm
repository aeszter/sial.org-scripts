#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Generic interface to many archive formats.
#
# Run perldoc(1) on this script for additional documentation.
#
# TODO need option to dip into archive (read it) to check for possible
# security issues (like ../../ attacks and the like)?

use strict;
use File::Basename qw(fileparse);

# what to consider as a filename suffix seperator (all OS I've seen use
# a period, but you never know...)
my $suffix_char = '.';
my $suffix_re   = qr/\./;

my %defaults = load_defaults();

my $prefs_file = $ENV{'OSMCONF'} || '~/.osm/prefs';
my $data       = load_prefs( tilde_expand($prefs_file) );

use Getopt::Std;
my %opts;
getopts 'h?qpvc:d:', \%opts;

print_help() if $opts{'h'} or $opts{'?'} or not @ARGV;

if ( exists $opts{'q'} ) {
  $defaults{'quiet'} = 1;
  delete $defaults{'verbose'};
} elsif ( exists $opts{'v'} ) {
  delete $defaults{'quiet'};
  $defaults{'verbose'} = 1;
}

$defaults{'class'}    = $opts{'c'} if exists $opts{'c'};
$defaults{'dest'}     = $opts{'d'} if exists $opts{'d'};
$defaults{'preserve'} = 1          if exists $opts{'p'};

for my $file (@ARGV) {
  # TODO support remote URL?  e.g. a download would be needed first...
  unless ( -e $file ) {
    remark( 'notice', 'skipping as does not exist', { file => $file } );
    next;
  }

 ATTEMPT: for my $suffix ( get_suffixes($file), '*' ) {
    if ( exists $data->{'_suffixmap'}->{ $defaults{'class'} }->{$suffix} ) {
      for my $index (
        @{ $data->{'_suffixmap'}->{ $defaults{'class'} }->{$suffix} } ) {
        # TODO also need to pass in whether to use quiet, verbose, etc...
        last ATTEMPT
         if handle_file( { %defaults, file => $file },
          $data->{ $defaults{'class'} }->[$index] );
      }
    }
  }
}

sub handle_file {
  my $param  = shift;
  my $config = shift;

  my %tmp = %$config;
  $tmp{'file'} = $param->{'file'};
  for my $option (qw(quiet verbose preserve dest)) {
    delete $tmp{$option} unless exists $param->{$option};
  }
  delete $tmp{'destopt'} unless exists $param->{'dest'};

  $tmp{'exec'} =~ s/%{(\w+)}/$tmp{$1}||''/ge;
  $tmp{'exec'} = [ split /\s+/, $tmp{'exec'} ];

  system( @{ $tmp{'exec'} } ) == 0
   or remark(
    'warning',
    'bad exit status',
    { errno => $!, map { $_ => $tmp{$_} } qw(file name class) }
   )
   and return 0;

  return 1;
}

# given filename such as "foo.zip" or "bar.tar.gz" returns list of
# suffixes, longest first (e.g. qw(zip) or qw(tar.gz gz) for the
# previous example filenames).
sub get_suffixes {
  my $file = shift;

  my @portions = split /$suffix_re/, fileparse($file);
  return unless @portions > 1;

  return ( $portions[-1] ) if @portions == 2;

  my @suffixes;
  local $" = $suffix_char;
  for my $i ( 1 .. $#portions ) {
    push @suffixes, "@portions[$i..$#portions]"
  }
  return @suffixes;
}

sub load_prefs {
  my $file = shift;

  open my $fh, "< $file"
   or remark( 'error', 'could not load preferences', { file => $file } )
   and exit 101;

  my %data;

  my %tmp = load_defaults();

  while (<$fh>) {
    s/^\s+//;
    next if /^#/;
    chomp;

    if (/^$/) {
      if ( exists $tmp{'name'} ) {
        if ( exists $tmp{'suffix'} ) {
          $tmp{'suffix'} = [ map { s/^\.//; $_ } split / /, $tmp{'suffix'} ];
        }

        push @{ $data{ $tmp{'class'} } }, {%tmp};

        if ( exists $tmp{'suffix'} ) {
          for my $suffix ( @{ $tmp{'suffix'} } ) {
            push @{ $data{'_suffixmap'}->{ $tmp{'class'} }->{$suffix} },
             $#{ $data{ $tmp{'class'} } };
          }
        }

        %tmp = load_defaults();
      }
      next;
    }

    s/\s+$//;

    my ( $k, $v ) = split /\s+/, $_, 2;
    unless ( defined $k and $k =~ /^[\w.-]+$/ and defined $v ) {
      remark(
        'warning',
        'skipping invalid data',
        { file => 'prefs', line => $. }
      );
      next;
    }
    $tmp{$k} = $v;
  }

  return \%data;
}

# prefs from file get layered over this
sub load_defaults {
  my %defaults = ( class => 'expand', );
  return %defaults;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam($1))[7] : ( $ENV{'HOME'} || $ENV{'LOGDIR'} )
     }ex;
  }
  return wantarray ? @_ : "@_";
}

sub print_help {
  print <<"HELP";
Usage: $0 [options] file [file2 ..]

Generic interface to many archive formats.

Options:
  -h/-?  Display this message.

  -c cc  Use class 'cc' instead of default ($defaults{'class'}).

  -v     Be verbose (translation to subprogram varies).
  -p     Preserve permissions (support varies by subprogram).
  -d dd  Use destination directory 'dd' if supported by the
         subprogram in question.

Run perldoc(1) on this script for additional documentation.

HELP
  exit 100;
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}
