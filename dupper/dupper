#!/usr/bin/perl
#
# $Id$
# By Jeremy Mates <mailto:jmates@sial.org>
#
# Removes duplicate files, using no external programs to do
# the checksums (via Digest::MD5).  Recursive by default,
# but very customizable, use to -h option to see how.
#
# Distributed under the Artistic License:
# http://www.sial.org/artistic_license.txt
#
######################################################################
#
# MODULES

use Carp;
use Digest::MD5;
use File::Spec;
use Getopt::Std;

use strict;
use vars qw:$VERSION:;

######################################################################
#
# CONSTANTS

# set version for CVS revision
($VERSION = '$Revision$ ') =~ s/[^0-9.]//g;

my (%opts, $verbose, $quiet, %check);

# we reset this for each file to avoid OO overhead on each file
my $dig = new Digest::MD5;

######################################################################
#
# MAIN

# parse command-line options
getopts('h?vlgzuqp:s:', \%opts);

help() if exists($opts{'h'}) || exists($opts{'?'});

$verbose = 1 if exists $opts{'v'};
if (exists $opts{'q'}) {
    $verbose = 0;
    $quiet = 1;
}

# read from STDIN if no args left
chomp(@ARGV = <STDIN>) unless @ARGV;

# and flag the help text if nothing from STDIN
help() unless @ARGV;

# loop over arguments which presumably are a bunch of directories
foreach ( @ARGV ) {
    unless (-d) {
	warn 'Error: ', $_, " is not a directory.  Skipping.\n" unless $quiet;
	next;
    }
    parsedir ($_);

    # reset the %check hash between directories by default
    unless (exists $opts{'g'} || exists $opts{'z'}) {
	report (\%check, $_);
	%check = ();
    }
}

report (\%check, 'all');

######################################################################
#
# SUBROUTINES

sub parsedir {
    my $dir = shift;

    my @to_parse; # subdirs we may need to recurse into later

    # -z option allows checks to become single-directory
    # specific, as opposed to the parent-dir globalness of default
    # or the everywhere -g option
    %check = () if exists $opts{'z'};
    
    unless (opendir (DIR, $dir)) {
	warn 'Problem reading ', $dir, ': ', $!, "\n" unless $quiet;
	return;
    }

    # loop over sorted contents of directory, skipping . and .. specials
    foreach (sort (readdir (DIR))) {
	next if /^\.{1,2}$/;
	my $pti = File::Spec->catfile($dir, $_);

	next if -l $pti; # skip links. Links bad. :)
	
	# only deal with files when doing sums
	if (-f $pti) {
	    # first check whether we skip this file
	    if (exists $opts{'s'}) {
		my $result = eval "return 1 if( " . $opts{'s'} . " );";
		
		if($@) {
		    chomp($@);
		    die "Skip error: ", $@; # croak on errors
		}
		
		if($result) {
		    next;
		}
	    }

	    # open up file, then hand it off to MD5 module
	    unless (open (FILE, $pti)) {
		warn 'Problem reading ', $pti, ': ', $!, "\n";
		next;
	    }

            # reset checksum object, then get new Checksum on file
	    $dig->new();
	    $dig->addfile(*FILE);
	    my $sum = $dig->hexdigest;

	    close (FILE);
	    
	    # either add new checksum to hash, or delete the duplicate file
	    if (exists $check{$sum} && exists $opts{'u'}) {
		# show unlink statement, plus the file this one is dup'ing
		warn "unlink ", $pti, "\t(", $check{$sum}->[0], ")\n" if $verbose;
		unless (unlink $pti) {
		    warn 'Problem unlinking ', $pti, 
		    ' (dup ', $check{$sum}->[0], '): ', $!, "\n";
		}		
	    }

	    # regardless, we add the file to the list of files
	    # associated with this particular hash
	    push (@{ $check{$sum} },  $pti);

	} elsif (-d $pti) {
            # see whether this dir needs to be pruned from the search
            if (exists $opts{'p'}) {
                my $results = eval "return 1 if( " . $opts{'p'} . " );";
                
                if($@) {
                    chomp($@);
                    die "Prune error: ", $@; # croak on errors
                }

                if($results) {
		    warn "Pruned $pti\n" if $verbose;
                    next;
                }
            }
	    push(@to_parse, $pti) unless exists $opts{'l'};
	}
    }

    # print a report if we're doing the local-dir-only thing
    report (\%check, $dir) if exists $opts{'z'};

    # before poping up a recursion level, deal with subdirs
    unless (exists $opts{'l'}) {
	foreach (@to_parse) {
	    parsedir ($_);
	}
    }
}

# takes a hash reference (presumably to %check) and
# dumps out a little report of duplicate files
sub report {
    my $ref = shift;
    my $dir = shift;

    # quit out early if no-yak mode turned on
    return if exists $opts{'q'};

    # rummage through hash, printing out only hash entries
    # that have more than 1 file associated with them
    foreach ( keys %$ref ) {
	if (scalar @{$ref->{$_}} > 1) {
	    print $dir, "\t", join(', ', @{$ref->{$_}}), "\n";
	}
    }
}

# a generic help blarb
sub help {
    print <<"HELP";
$0 v.$VERSION
Usage: $0 [options] directory1 [dir2 .. dirN]

Removes duplicate files based on checksum comparison of
file contents.

Options:
  -h/-?  Display this message
  -v     Verbose mode, a little bit more chatty.
  -q     Chat no more.  Overrides -v, suppresses reporting.

  -u     Attempt to unlink any duplicates found past first.
         (Default is not to unlink anything, just report.  Files
         are added least-depth first by order of sort().)

  -l     Local mode only, script does not recurse into subdirs.

  -g     Make checksums apply across all directories on command line.
  -z     Overrides g; limits scope of checksums to only other files in
         the same directory.

  -s xx  Perl expression that will result in the current file (stored in \$_)
         being skipped if the expression turns out to be "true."  Example:

         -s 'm/^\\.rsrc\$/ || -z $pti'

         Would skip the checksum on files named '.rsrc', or files that are
         empty via the -z is-empty test.

  -p xx  Perl expression that will result in the current directory (stored in 
         \$_) being pruned out of the tree.  Like config dirs, for example:

         -p 'm/etc/'

         Both -s and -p have access to the filename in \$_, and can find
         the full filepath in the variable \$pti.
HELP
    exit;
}
