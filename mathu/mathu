#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Performs various mathematical and statistical operations on
# input data.

my %ability = (
  sum     => {handle => \&handle_sum,},
  mean    => {handle => \&handle_mean,},
  sdev    => {handle => \&handle_sdev,},
  percent => {handle => \&handle_percent,},
  max     => {handle => \&handle_max,},
  min     => {handle => \&handle_min,},
  basic   => {handle => \&handle_basic,},
);

# how to format output numbers with printf
my $format = '%.2f';

# parse command-line options
use Getopt::Std;
my %opts;
getopts('lf:', \%opts);

# lists abilities, good for tab completion systems to query
if (exists $opts{l}) {
  print join (" ", sort keys %ability), "\n";
  exit 1;
}

my $action = shift;
die "error: no such action: $action\n" unless exists $ability{$action};

$format = $opts{f} if exists $opts{f};

$ability{$action}->{handle}();

sub handle_sum {
  my $result;
  while (<STDIN>) {
    chomp;
    $result += $_;
  }
  $result = numbertidy($result) if $result =~ /\./;
  print $result, "\n";
}

sub handle_mean {
  my @array;
  chomp(@array = <STDIN>);
  my $result = mean(\@array);
  $result = numbertidy($result) if $result =~ /\./;
  print $result, "\n";
}

sub handle_sdev {
  my @array;
  chomp(@array = <STDIN>);
  my $result = standard_deviation(\@array, mean(\@array));
  $result = numbertidy($result) if $result =~ /\./;
  print $result, "\n";
}

sub handle_percent {
  printf "$format%%\n", $ARGV[0] / $ARGV[1] * 100;
}

sub handle_max {
  my $result;
  while (<STDIN>) {
    chomp;
    $result ||= $_;
    $result = $_ if $_ > $result;
  }
  $result = numbertidy($result) if $result =~ /\./;
  print $result, "\n";
}

sub handle_min {
  my $result;
  while (<STDIN>) {
    chomp;
    $result ||= $_;
    $result = $_ if $_ < $result;
  }
  $result = numbertidy($result) if $result =~ /\./;
  print $result, "\n";
}

sub handle_basic {
  my @array;
  my %results;

  while (<STDIN>) {
    chomp;
    $results{sum} += $_;
    $results{min} ||= $_;
    $results{min} = $_ if $_ < $results{min};
    $results{max} ||= $_;
    $results{max} = $_ if $_ > $results{max};
    push @array, $_;
  }
  $results{mean} = mean(\@array, $results{sum});
  $results{sdev} = standard_deviation(\@array, $results{mean});

  print map {
    $_ . " "
     . ($results{$_} =~ /\./ ? numbertidy($results{$_}) : $results{$_}) . "\n"
  } sort keys %results;
}

sub numbertidy {
  my @tidyied = map {
    $_ = sprintf "$format", $_;
    s/0+$//;
    $_;
  } @_;

  return wantarray ? @tidyied : $tidyied[0];
}

# $mean = mean(\@array) computes the mean of an array of numbers.
sub mean {
  my $arrayref = shift;
  my $sum      = shift;
  unless ($sum) {
    for (@$arrayref) { $sum += $_ }
  }
  return $sum / @$arrayref;
}

# $sd = standard_deviation_data(\@array) computes the standard
# deviation of an array of numbers.
sub standard_deviation {
  my $arrayref = shift;
  my $mean     = shift;

  return sqrt(mean([map (($_ - $mean)**2, @$arrayref)]));
}
