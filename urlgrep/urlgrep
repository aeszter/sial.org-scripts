#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Extracts links from a requested document and runs them by a supplied
# Perl regular expression to grep for URL. Hence, 'urlgrep' as the name.
#
# Run perldoc(1) on this script for additional documentation.

use strict;

use File::Basename qw(basename);
my $basename = basename($0);

my $output_tmpl = '%{url}\n';

use HTML::TokeParser ();
use LWP::UserAgent   ();
use URI              ();

use Getopt::Std;
my %opts;
getopts 'h?Tb:o:', \%opts;

$output_tmpl = $opts{o} if exists $opts{o};
$opts{T} = 1 if $output_tmpl =~ m/%{text}/;

# fix backslashed characters to literal, add newline if no trailing
# whitespace found
$output_tmpl =~ s/(\\.)/qq!"$1"!/eeg;
$output_tmpl .= "\n" unless $output_tmpl =~ m/ \s$ /x;

print_help() if exists $opts{h} or exists $opts{'?'} or not @ARGV;
my $base_uri = $opts{b} if exists $opts{b};

my $document = shift;
# regular expression, or match everything by default
my $pattern = shift || qr/^/;

# TODO this might be xlink:href in XML... ?
my $href = 'href';

my $urls = parse_document( get_document($document), $base_uri );

unless (@$urls) {
  remark( 'error', 'no URL found', { source => $document } );
  exit 101;
}

# TODO need template output, and means to select "a href" along with
# others like img src or anything with a href...
for my $result (@$urls) {
  next unless $result->{url} =~ m/$pattern/o;

  my $str_out = $output_tmpl;
  $str_out =~ s/ %{ (\w+) } / defined $result->{$1} ? $result->{$1} : '' /egx;
  print $str_out;
}

# gets document into something HTML::TokeParser can deal with
sub get_document {
  my $document = shift;
  return { document => $document, source => \*STDIN } if $document eq '-';

  my $source;
  $source->{document} = $document;

  my $target = URI->new($document);

  if ( $target->scheme ) {
    # TODO URL lookup needs more error checking
    my $ua =
     LWP::UserAgent->new( env_proxy => 1, keep_alive => 0, timeout => 30 );
    $ua->agent( $ENV{http_agent} ) if exists $ENV{http_agent};
    my $response = $ua->get( $target->canonical );
    if ( $response->is_success ) {
      $source->{base_uri} = $target->canonical->as_string;
      delete $source->{base_uri}
       unless defined $source->{base_uri}
       and length $source->{base_uri} >= 1;
      $source->{source} = \$response->content;
    } else {
      remark(
        'error',
        'could not fetch resource',
        { status => $response->code, errno => $response->message }
      );
      exit 102;
    }
  } else {
    # treat as filename as no scheme
    $source->{source} = $target->canonical->as_string;
  }

  return $source;
}

# pulls out URL from document
sub parse_document {
  my $source   = shift;
  my $base_uri = shift;

  my $p = HTML::TokeParser->new( $source->{source} );
  unless ($p) {
    remark(
      'error',
      'could not parse document',
      { source => $source->{document}, errno => $! }
    );
    exit 103;
  }

  my ( @found, $inbody, $seenbase, %seenurl );

  # command line base_uri wins if set
  $seenbase = 1 if defined $base_uri;

  while ( my $token = $p->get_tag ) {
    $inbody = 1 if $token->[0] eq 'body' or $token->[0] eq '/head';

    # skip closing tags
    next if $token->[0] =~ m{^/};

    # pull optional <base> from HTML header
    if ( not $inbody and not $seenbase and $token->[0] eq 'base' ) {
      my $url = get_url_from_token($token);
      $base_uri = $url if $url;
      $seenbase = 1;
    }

    # check if this tag is something we want
    # TODO img use src, not href...
    my $url = get_url_from_token($token);
    if ($url) {
      # TODO unique gets tricky, if looking for 'a href' or 'img src'
      # but do or do not want URL that are set for both?
      next if exists $seenurl{"$token->[0].$href.$url"};
      $seenurl{"$token->[0].$href.$url"} = 1;

      my $result = { element => $token->[0], attribute => $href, url => $url };

      # save text inside <a> with URL for reference
      if ( exists $opts{T} and $token->[0] eq 'a' ) {
        $result->{text} = $p->get_trimmed_text('/a');
        delete $result->{text}
         unless defined $result->{text}
         and length $result->{text} >= 1;
      }
      push @found, $result;
    }
  }

  # set base_uri from document URL if possible (allows command line or
  # <base> to take precedence)
  if ( not defined $base_uri and defined $source->{base_uri} ) {
    $base_uri = $source->{base_uri};
  }

  for my $result (@found) {
    my $uri;
    if ($base_uri) {
      $uri = URI->new_abs( $result->{url}, $base_uri )->canonical->as_string;
      $result->{base_uri} = $base_uri;
    } else {
      $uri = URI->new( $result->{url} )->canonical->as_string;
    }
    unless ($uri) {
      remark(
        'warning',
        'skipping URL as unable to canonicalize',
        { url => $result->{url} }
      );
      next;
    }
    $result->{url}    = $uri;
    $result->{source} = $source->{document};
  }

  return \@found;
}

sub get_url_from_token {
  my $token = shift;
  my $href = shift || $href;
  return
   unless exists $token->[1]{$href}
   and defined $token->[1]{$href}
   and length $token->[1]{$href} >= 1;
  return $token->[1]{$href};
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}

sub print_help {
  warn "usage: $basename [opts] URL|file|- [regular-expression]\n";
  warn "\nRun perldoc(1) on this script for additional documentation.\n\n";
  exit 100;
}

__DATA__

=head1 NAME

urlgrep - extract links from a given URL or file

=head1 SYNOPSIS

List the RPM for PostgreSQL of the 7.4 version, first release.

  $ urlgrep http://www.postgresql.org/download.html \
    '/7\.4-1\.[^.]+\.rpm$'

Match any C<*.patch> files on the OpenBSD errata page and download any
with C<wget>.

  $ urlgrep http://openbsd.org/errata.html '.patch$' | \
    xargs wget

=head1 DESCRIPTION

=head2 Overview

Provides a means to list URL in a given HTML document, limited by an
optional Perl regular expression. Useful when one is looking for a
specific (matchable) set of documents listed on a page, where there are
too many or too large false positives to justify simply downloading all
links from a page.

=head2 Normal Usage

  $ urlgrep [options] URL|file|- [regular-expression]

See L<"OPTIONS"> for details on the command line switches supported.

The script will determine whether a URL, a file, or standard input (via
a filname of C<->) should be parsed as HTML for links. An optional Perl
regular expression can be specified to limit matches. Any matched URL
will be printed to standard output, and any errors or warnings to
standard error.

Use of a caching proxy is recommended, as numerous hits on an URL may be
required while fine tuning a regular expression. If possible, this
script will use a proxy specified by the standard unix proxy environment
variables of C<http_proxy> and C<ftp_proxy>.

  $ export http_proxy=http://proxy:3128
  $ urlgrep ... | xargs wget --continue --proxy=on --passive-ftp

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note about the script.

=item B<-b> I<base-url>

Specify custom base URL that will be used to qualify any relative links
in the document. This custom URL will override any C<base> element found
in the document, or the URL if a URL was specified to download instead
of a local file or standard input.

=item B<-T>

Save text inside any C<a href> tags for reference in the C<text> macro.
Enabled automatically if C<%{text}> found in custom output template.

=item B<-o> I<template>

Use custom output I<template> to change default output format. By
default, each URL is printed on a different line via a template of
C<%{url}\n>. The I<template> will expand any backslashed single
characters, allowing tabs and similar characters in the output, and a
newline will be appended to the template if the template does not end in
whitespace.

  -o '%{url}\t%{text}'

Macros that can be enclosed inside C<%{}> statements include the
following.

  url       - URL in question.

  element   - Name of the element from which the URL is from,
              typically 'a'.
  attribute - Name of the attribute from which the URL is from,
              usually 'href'.

  source    - URL or filename of original document.
  text      - Text inside any C<a href> element, if any.

=back

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No known issues. See the source for TODO and other ideas for
improvements.

=head1 SEE ALSO

perl(1), HTML::TokeParser, LWP::UserAgent, URI

=head1 AUTHOR

Jeremy Mates, http://sial.org/contact/

=head1 COPYRIGHT

The author disclaims all copyrights and releases this script into the
public domain.

=head1 VERSION

  $Id$

=cut
