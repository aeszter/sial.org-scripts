#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Checks and handles expiry dates. Supports x509 certificates, and
# ideally anything a wrapper script can be written for.
#
# Run perldoc(1) on this script for additional documentation.

use strict;

use Date::Parse qw(str2time);
use File::Temp qw(tempfile);

my $cur_epoch = time;
my $expire_epoch;

my %actions;
{
  no strict 'refs';
  my $pkgname = __PACKAGE__ . '::';
  %actions = (
    map { $_ =~ m/^ do_ (\w{1,32}) /x ? ( $1 => $_ ) : () }
      keys %$pkgname
  );
}

use Getopt::Std;
my %opts;
getopts 'h?e:', \%opts;

my $expire_window = duration2seconds( $opts{e} || '7d' );

if ( exists $opts{h} or exists $opts{'?'} or not @ARGV ) {
  print_help();
  exit 101;
}

my $op_mode = shift || die "Usage: $0 [options] mode [arguments]\n";
$op_mode =~ tr/-/_/;

die "error: unknown handler: mode=$op_mode\n"
  unless exists $actions{$op_mode};
{
  no strict 'refs';
  $expire_epoch = $actions{$op_mode}->(@ARGV);
}

# this is for SiteScope, need to tempalate output...
# two conditions: already expired, or about to
# TODO boundary test all the possibilities to confirm logic!!
# TODO also need to save extra data for templating, like how far
# away the expire is, or how far past?
my $return_code =
    ( $cur_epoch >= $expire_epoch ) ? 2
  : ( $cur_epoch - $expire_window ) <= $expire_epoch ? 1
  : 0;

print "Return Code: $return_code\n";
exit $return_code;

sub date_openssl2epoch {
  my $date = shift;

  my $time = str2time($date);
  return $time;
}

sub do_openssl_x509 {
  my @x509_arguments = @_;

  my @command = ( qw{openssl x509 -noout -enddate}, @x509_arguments );

  my $results = get_output(@command);
  if ( !$results ) {
    die "error: no output: command=@command\n";
  }

  my $date_str;
  while ( my $line = <$results> ) {
    if ( $line =~ m/^notAfter=(.+)/ ) {
      return date_openssl2epoch($1);
    }
  }

  return;
}

sub do_openssl_sclient {
  my @sclient_arguments = @_;
  my $results = get_output( qw{openssl s_client}, @sclient_arguments );

  my ( $tmp_fh, $filename ) = tempfile( UNLINK => 1 );
  die "error: no temporary file created\n" unless $tmp_fh;
  print $tmp_fh, <$results>;

  return do_openssl_x509( '-in', $filename );
}

sub get_output {
  my $param = {};
  if ( @_ and ref $_[0] eq 'HASH' ) {
    $param = { %$param, %{ $_[0] } };
    shift @_;
  }

  my @command = @_;
  return unless @command;

  #remark( 'debug', 'command run', { command => "@command" } );

  my $timeout = $param->{timeout} || 60;

  my $result_fh;

  eval {
    local $SIG{ALRM} = sub { die "alarm\n" };

    alarm $timeout;

    #unless ( exists $ENV{CFALLCLASSES}
    #  and $ENV{CFALLCLASSES} =~ m/\bcf_debug\b/ ) {
    #  close STDERR;
    #}

    open $result_fh, '-|' or exec @command;

    if ( !$result_fh ) {
      remark(
        'error',
        'could not run',
        { command => "@command", errno => $! }
      );
    }

    #unless ( exists $ENV{CFALLCLASSES}
    #  and $ENV{CFALLCLASSES} =~ m/\bcf_debug\b/ ) {
    #  open STDERR, ">&SAVERRR";
    #}

    alarm 0;
  };
  if ($@) {
    unless ( $@ eq "alarm\n" ) {
      chomp $@;
      remark(
        'error',
        'unexpected command error',
        { command => "@command", errno => $@ }
      );
      return;
    }

    remark(
      'warning',
      'command timed out',
      { command => "@command", timeout => $timeout }
    );
    return;
  }

  # TODO use POSIX for portable exit status checking?
  my %result = (
    exit_value => $? >> 8,
    signal_num => $? & 127,
  );

  # invert exit logic (0 == good) to work with standard Perl checks;
  # real exit in hash if needed
  my $status = $result{exit_value} ? 0 : 1;

  return $result_fh;
}

sub duration2seconds {
  my $tmpdur = shift;
  my $seconds;

  # how to convert short human durations into seconds
  my %factor = (
    w => 604800,
    d => 86400,
    h => 3600,
    m => 60,
    s => 1,
  );

  # assume raw seconds for plain number
  if ( $tmpdur =~ m/^\d+$/ ) {
    $seconds = $tmpdur * 60;

  } elsif ( $tmpdur =~ m/^[wdhms\d\s]+$/ ) {

    # match "2m 5s" style input and convert to seconds
    while ( $tmpdur =~ m/(\d+)\s*([wdhms])/g ) {
      $seconds += $1 * $factor{$2};
    }
  } else {
    die "error: unknown characters in duration: input=$tmpdur\n";
  }

  unless ( defined $seconds and $seconds =~ m/^\d+$/ ) {
    die "error: unable to parse duration: input=$tmpdur\n";
  }

  return $seconds;
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
      map { $attributes->{$_} ||= q{}; "$_=$attributes->{$_}" }
      sort keys %$attributes;
  }

  print STDERR "$priority: $message"
    . ( $attr_str ? ": $attr_str" : q{} ) . "\n";
  return 1;
}

sub print_help {
  print <<"END_USAGE";
Usage: $0 [options] mode [arguments]

Expiration date handler.

Options:
  -h/-?  Display this message.

Run perldoc(1) on this script for additional documentation.

END_USAGE
  return;
}
