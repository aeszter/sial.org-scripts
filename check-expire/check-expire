#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Checks and handles expiry dates. Supports x509 certificates, and
# ideally anything a wrapper script can be written for.
#
# Run perldoc(1) on this script for additional documentation.

use strict;

use Config::General qw(ParseConfig);
use Date::Parse qw(str2time);
use File::Temp qw(tempfile);

use File::Basename qw(basename);
my $basename = basename($0);

my $cur_epoch = time;
my $expire_epoch;

# subroutine table for different modes of operation
my %actions;

# parse for date using 'openssl x509'
$actions{openssl_x509} = sub {
  my @x509_arguments = @_;

  # TODO parse for more options, like start date and
  # subject/fingerprint, so can include them in output templating
  my @command = ( qw{openssl x509 -noout -enddate}, @x509_arguments );

  my $results = get_output(@command);
  if ( !defined $results ) {
    die "error: no output: command=@command\n";
  }

  my $date_str;
  for my $line (@$results) {
    if ( $line =~ m/^notAfter=(.+)/ ) {
      return date_openssl2epoch($1);
    }
  }

  return;
};

# runs a command that should return a certificate to stdout that
# 'openssl x509' can parse for the dates
$actions{certificate} = sub {
  my @command = @_;
  my $results = get_output(@command);
  if ( !defined $results ) {
    die "error: no output: command=@command\n";
  }

  my ( $tmp_fh, $filename ) = tempfile();
  die "error: no temporary file created\n" unless $tmp_fh;
  for my $line (@$results) {
    print $tmp_fh $line;
  }

  return $actions{openssl_x509}->( '-in', $filename );
};

my @actions = sort keys %actions;

use Getopt::Std;
my %opts;
getopts 'h?l:c:f:', \%opts;

if ( exists $opts{l} ) {
  print "@actions\n";
  exit;
}

if ( exists $opts{h} or exists $opts{'?'} or not @ARGV ) {
  print_help();
  exit 100;
}

my %config = ParseConfig( -ConfigFile => $opts{f}, -LowerCaseNames => 1 );

my $op_mode = shift || q{};
$op_mode =~ tr/-/_/;

if ( !exists $actions{$op_mode} ) {
  remark( 'error', 'unknown mode',
    { allowed => join( q{,}, @actions ), mode => $op_mode } );
  print_help();
  exit 101;
}

$expire_epoch = $actions{$op_mode}->(@ARGV);

if ( !defined $expire_epoch ) {
  die "error: no expire date found\n";
}

# where in the prefs to read expire, window handlers from
my $report_handler = exists $opts{c} ? $opts{c} : 'default';
my $report_ref     = $config{class}->{$report_handler};

# check whether expired, or if within a window
if ( $expire_epoch <= $cur_epoch ) {
  # TODO fill out more parameters (humanized time? strftime, parameters
  # about the certificate, and etc.? - see what need for reporting)
  handle_condition(
    $report_ref->{expired},
    { name         => 'expired',
      expire_epoch => $expire_epoch,
      cur_epoch    => $cur_epoch,
      seconds_ago  => $cur_epoch - $expire_epoch,
    }
  );
} else {

  if ( @{ $report_ref->{window} } ) {

    # build Windows to look at (sanity checks, duration conversion)
    my @windows;
    for my $window_ref ( @{ $report_ref->{window} } ) {
      if ( !exists $window_ref->{inside} ) {
        remark( 'error', 'skipping window without date setting' );
        next;
      }
      $window_ref->{inside} = duration2seconds( $window_ref->{inside} );
      push @windows, $window_ref;
    }

    for my $window_ref ( sort { $a->{inside} <=> $b->{inside} } @windows ) {
      if ( $expire_epoch <= ( $cur_epoch + $window_ref->{inside} ) ) {

        handle_condition(
          $window_ref,
          { name         => 'warning',
            export_epoch => $expire_epoch,
            cur_epoch    => $cur_epoch,
            seconds_left => $expire_epoch - $cur_epoch,
          }
        );
        die "error: handler did not exit script\n";
      }
    }
  }

  if ( exists $report_ref->{default} ) {
    handle_condition(
      $report_ref->{default},
      { name         => 'default',
        export_epoch => $expire_epoch,
        cur_epoch    => $cur_epoch,
        seconds_left => $expire_epoch - $cur_epoch,
      }
    );
  }
}
die "error: no handles found\n";

# parses handler prefs from under config, figures out what to do...
sub handle_condition {
  my $handle_ref = shift;
  my $param_ref  = shift;

  if ( !exists $handle_ref->{exit_value} ) {
    $handle_ref->{exit_value} = 0;
  }

  my %handlers = (
    exec => sub {
      my $cmd_str   = shift;
      my $param_ref = shift;

      # TODO need grammar parser to pull out "" strings...
      my @command = split /(?<!\\)\s+/, $cmd_str;
      for my $part (@command) {
        $part =~ s/ %{ ([^}]+) } / $param_ref->{$1} || '' /egx;
        $part =~ s/(\\.)/qq("$1")/eeg;
      }

      my $status = system @command;
      if ( $status != 0 ) {
        remark(
          'warning',
          'command failed',
          { command => "@command", errno => $? }
        );
      }

      return;
    },
    pipe => sub {
      my $cmd_str   = shift;
      my $param_ref = shift;

      my @command = split /(?<!\\)\s+/, $cmd_str;

      for my $part (@command) {
        $part =~ s/ %{ ([^}]+) } / $param_ref->{$1} || '' /egx;
        $part =~ s/(\\.)/qq("$1")/eeg;
      }
      my $stdin = shift @command;

      open TO_COMMAND, '|-' or exec @command or return;
      print TO_COMMAND "$stdin\n";
      close TO_COMMAND;

      return;
    },
    stdout => sub {
      my $output_str = shift;
      my $param_ref  = shift;

      $output_str =~ s/ %{ ([^}]+) } / $param_ref->{$1} || '' /egx;
      $output_str =~ s/(\\.)/qq("$1")/eeg;
      print "$output_str\n";

      return;
    }
  );

  for my $handle (qw{stdout exec pipe}) {
    if ( exists $handle_ref->{$handle} ) {
      if ( ref $handle_ref->{$handle} eq 'ARRAY' ) {
        for my $item ( @{ $handle_ref->{$handle} } ) {
          $handlers{$handle}->( $item, $param_ref );
        }
      } else {
        $handlers{$handle}->( $handle_ref->{$handle}, $param_ref );
      }
    }
  }

  exit $handle_ref->{exit_value};
}

sub date_openssl2epoch {
  my $date = shift;

  my $time = str2time($date);
  return $time;
}

# takes command to run (and optional leading hashref with parameters),
# returns filehandle (or undef on error) with STDOUT of program
sub get_output {
  my $param = {};
  if ( @_ and ref $_[0] eq 'HASH' ) {
    $param = { %$param, %{ $_[0] } };
    shift @_;
  }

  my @command = @_;
  return unless @command;

  #remark( 'debug', 'command run', { command => "@command" } );

  my $timeout = $param->{timeout} || 60;

  my @results;

  eval {
    local $SIG{ALRM} = sub { die "alarm\n" };

    alarm $timeout;

    open OUTPUT, '-|' or exec @command or die "exec error\n";
    @results = <OUTPUT>;
    close OUTPUT;

    alarm 0;
  };
  if ($@) {
    my $error_str =
        $@ eq "alarm\n"      ? 'command timed out'
      : $@ eq "exec error\n" ? undef
      : 'unexpected command error';

    if ( defined $error_str ) {
      chomp $@;
      remark( 'error', $error_str, { command => "@command", errno => $@ } );
    }
  }

  return @results ? \@results : undef;
}

sub duration2seconds {
  my $tmpdur = shift;
  my $seconds;

  # how to convert short human durations into seconds
  my %factor = (
    y => 31536000,
    w => 604800,
    d => 86400,
    h => 3600,
    m => 60,
    s => 1,
  );

  # assume raw seconds for plain number
  if ( $tmpdur =~ m/^\d+$/ ) {
    $seconds = $tmpdur * 60;

  } elsif ( $tmpdur =~ m/^[ywdhms\d\s]+$/ ) {

    # match "2m 5s" style input and convert to seconds
    while ( $tmpdur =~ m/(\d+)\s*([ywdhms])/g ) {
      $seconds += $1 * $factor{$2};
    }
  } else {
    die "error: unknown characters in duration: input=$tmpdur\n";
  }

  unless ( defined $seconds and $seconds =~ m/^\d+$/ ) {
    die "error: unable to parse duration: input=$tmpdur\n";
  }

  return $seconds;
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
      map { $attributes->{$_} ||= q{}; "$_=$attributes->{$_}" }
      sort keys %$attributes;
  }

  print STDERR "$priority: $message"
    . ( $attr_str ? ": $attr_str" : q{} ) . "\n";
  return 1;
}

sub print_help {
  print <<"END_USAGE";
Usage: $basename [options] mode [arguments]

Expiration date handler.

Options:
  -h/-?  Display this message.

Run perldoc(1) on this script for additional documentation.

END_USAGE
  return;
}

# TODO write perldoc
