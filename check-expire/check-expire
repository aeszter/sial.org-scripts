#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Checks and handles expiry dates. Supports x509 certificates, and
# ideally anything a wrapper script can be written for.
#
# Run perldoc(1) on this script for additional documentation.

use strict;

use Date::Parse qw(str2time);
use File::Temp qw(tempfile);

use File::Basename qw(basename);
my $basename = basename($0);

my $cur_epoch = time;
my $expire_epoch;
# TODO window will vary by notification rule (e.g. e-mail ~30d, pages
# and dire warnings around ~7d)
my $expire_window;

my %actions;
$actions{openssl_x509} = sub {
  my @x509_arguments = @_;

  my @command = ( qw{openssl x509 -noout -enddate}, @x509_arguments );

  my $results = get_output(@command);
  if ( !defined $results ) {
    die "error: no output: command=@command\n";
  }

  my $date_str;
  for my $line (@$results) {
    if ( $line =~ m/^notAfter=(.+)/ ) {
      return date_openssl2epoch($1);
    }
  }

  return;
};

# runs a command that should return a certificate to stdout that
# 'openssl x509' can parse for the dates
$actions{certificate} = sub {
  my @command = @_;
  my $results = get_output(@command);
  if ( !defined $results ) {
    die "error: no output: command=@command\n";
  }

  my ( $tmp_fh, $filename ) = tempfile();
  die "error: no temporary file created\n" unless $tmp_fh;
  for my $line (@$results) {
    print $tmp_fh $line;
  }

  return $actions{openssl_x509}->( '-in', $filename );
};

my @actions = sort keys %actions;

use Getopt::Std;
my %opts;
getopts 'h?e:l:', \%opts;

if ( exists $opts{l} ) {
  print "@actions\n";
  exit;
}

if ( exists $opts{h} or exists $opts{'?'} or not @ARGV ) {
  print_help();
  exit 100;
}

$expire_window = duration2seconds( $opts{e} || '7d' );

my $op_mode = shift || q{};
$op_mode =~ tr/-/_/;

if ( !exists $actions{$op_mode} ) {
  remark( 'error', 'unknown mode',
    { allowed => join( q{,}, @actions ), mode => $op_mode } );
  print_help();
  exit 101;
}

$expire_epoch = $actions{$op_mode}->(@ARGV);

if ( !defined $expire_epoch ) {
  die "error: no expire date found\n";
}

warn "expire: $expire_epoch\n";    # DBG

# this is for SiteScope, need to tempalate output...
# two conditions: already expired, or about to
# TODO boundary test all the possibilities to confirm logic!!
# TODO also need to save extra data for templating, like how far
# away the expire is, or how far past?
my $return_code = 0;
if ( $expire_epoch <= $cur_epoch ) {
  $return_code = 2;
} elsif ( $expire_epoch <= ( $cur_epoch + $expire_window ) ) {
  $return_code = 1;
}

print "Return Code: $return_code\n";
exit $return_code;

sub date_openssl2epoch {
  my $date = shift;

  my $time = str2time($date);
  return $time;
}

# takes command to run (and optional leading hashref with parameters),
# returns filehandle (or undef on error) with STDOUT of program
sub get_output {
  my $param = {};
  if ( @_ and ref $_[0] eq 'HASH' ) {
    $param = { %$param, %{ $_[0] } };
    shift @_;
  }

  my @command = @_;
  return unless @command;

  #remark( 'debug', 'command run', { command => "@command" } );

  my $timeout = $param->{timeout} || 60;

  my @results;

  eval {
    local $SIG{ALRM} = sub { die "alarm\n" };

    alarm $timeout;

    open OUTPUT, '-|' or exec @command or die "exec error\n";
    @results = <OUTPUT>;
    close OUTPUT;

    alarm 0;
  };
  if ($@) {
    my $error_str =
        $@ eq "alarm\n"      ? 'command timed out'
      : $@ eq "exec error\n" ? undef
      : 'unexpected command error';

    if ( defined $error_str ) {
      chomp $@;
      remark( 'error', $error_str, { command => "@command", errno => $@ } );
    }
  }

  return @results ? \@results : undef;
}

sub duration2seconds {
  my $tmpdur = shift;
  my $seconds;

  # how to convert short human durations into seconds
  my %factor = (
    y => 31536000,
    w => 604800,
    d => 86400,
    h => 3600,
    m => 60,
    s => 1,
  );

  # assume raw seconds for plain number
  if ( $tmpdur =~ m/^\d+$/ ) {
    $seconds = $tmpdur * 60;

  } elsif ( $tmpdur =~ m/^[ywdhms\d\s]+$/ ) {

    # match "2m 5s" style input and convert to seconds
    while ( $tmpdur =~ m/(\d+)\s*([ywdhms])/g ) {
      $seconds += $1 * $factor{$2};
    }
  } else {
    die "error: unknown characters in duration: input=$tmpdur\n";
  }

  unless ( defined $seconds and $seconds =~ m/^\d+$/ ) {
    die "error: unable to parse duration: input=$tmpdur\n";
  }

  return $seconds;
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
      map { $attributes->{$_} ||= q{}; "$_=$attributes->{$_}" }
      sort keys %$attributes;
  }

  print STDERR "$priority: $message"
    . ( $attr_str ? ": $attr_str" : q{} ) . "\n";
  return 1;
}

sub print_help {
  print <<"END_USAGE";
Usage: $basename [options] mode [arguments]

Expiration date handler.

Options:
  -h/-?  Display this message.

Run perldoc(1) on this script for additional documentation.

END_USAGE
  return;
}

# TODO write perldoc
