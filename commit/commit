#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Wrapper to commit changes back to version control programs.
#
# TODO add status/add checking support, to avoid "commit" grrr! "add"
# "commit" annoyance.

use strict;

my %defaults = ( class => 'commit' );

my $prefs_file = $ENV{'COMMITCONF'} || '~/.commit/prefs';
$prefs_file = tilde_expand($prefs_file);
my $prefs = load_prefs($prefs_file);

use Getopt::Std;
my %opts;
getopts 'h?f:m:r:n', \%opts;

$defaults{'revision'} = $opts{'r'} if exists $opts{'r'};
if ( exists $opts{'m'} ) {
  $defaults{'msg'} = $opts{'m'};
} elsif ( exists $opts{'f'} ) {
  $defaults{'msgfile'} = $opts{'f'};
}

# default to "current" directory if no args (to emulate 'cvs ci'
# without args)
@ARGV = qw(.) unless @ARGV;

use File::Basename;
use File::Spec ();

# where to store filenames for handling
my ( %tocommit, @unknown );

for my $file (@ARGV) {
  my ( $filename, $filepath, undef ) = fileparse($file);
  if ( -f File::Spec->catfile( $filepath, qw{CVS ROOT} ) ) {
    push @{ $tocommit{'cvs'} }, $file;
  } elsif ( -f File::Spec->catfile( $filepath, qw{.svn entries} ) ) {
    push @{ $tocommit{'svn'} }, $file;
  } else {
    push @unknown, $file;
  }
}

for my $commit_type ( sort keys %tocommit ) {

  my %tmp = ( %{ $prefs->{'commit'}->{$commit_type} }, %defaults );
  $tmp{'files'} = join ' ', @{ $tocommit{$commit_type} };

  # delete "whateveropt" where no "whatever" exists
  for my $option ( keys %tmp ) {
    delete $tmp{$option} if $option =~ /(\w+)opt$/ and not exists $tmp{$1};
  }

  $tmp{'exec'} =~ s/%{(\w+)}/$tmp{$1}||''/ge;

  my @command = split /\s+/, $tmp{'exec'};
  unshift @command, 'echo' if exists $opts{'n'};

  unless ( system(@command) == 0 ) {
    remark(
      'warning',
      'bad exit status',
      { errno => $!, type => $commit_type }
    );
  }
}

if (@unknown) {
  local $" = ',';
  remark( 'warning', 'no method to handle', { files => "@unknown" } );
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam $1)[7] : (getpwuid $<)[7] || $ENV{'HOME'}
        || remark('error',
	     'could not lookup user or HOME not set',
	     { file => $_ })
	&& exit 99;
     }ex;
  }
  return wantarray ? @_ : "@_";
}

sub load_prefs {
  my $file = shift;

  open my $fh, "< $file"
   or remark( 'error', 'could not load preferences', { file => $file } )
   and exit 101;

  my %prefs;
  my %tmp = %defaults;

  while (<$fh>) {
    s/^\s+//;
    next if /^#/;
    chomp;

    if (/^$/) {
      pref_finish( \%tmp, \%prefs ) if exists $tmp{'name'};
      %tmp = %defaults;
      next;
    }

    s/\s+$//;

    my ( $k, $v ) = split /\s+/, $_, 2;
    unless ( defined $k and $k =~ /^[\w.-]+$/ and defined $v ) {
      remark(
        'warning',
        'skipping invalid data',
        { file => 'prefs', line => $. }
      );
      next;
    }
    $tmp{$k} = $v;
  }
  pref_finish( \%tmp, \%prefs ) if exists $tmp{'name'};

  return \%prefs;
}

sub pref_finish {
  my $tmp   = shift;
  my $prefs = shift;

  $prefs->{ $tmp->{'class'} }->{ $tmp->{'name'} } = {%$tmp};
}
