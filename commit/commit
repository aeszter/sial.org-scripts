#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Wrapper to commit changes back to version control programs.
#
# TODO add status/add checking support, to avoid "commit" grrr! "add"
# "commit" annoyance.

use strict;

my %defaults = ( class => 'commit' );

my $prefs_file = $ENV{COMMITCONF} || '~/.commit/prefs';
$prefs_file = tilde_expand($prefs_file);
my $prefs = load_prefs($prefs_file);

use Getopt::Std;
my %opts;
getopts 'h?F:m:r:n', \%opts;

$defaults{revision} = $opts{r} if exists $opts{r};
if ( exists $opts{m} ) {
  $defaults{msg} = $opts{m};
} elsif ( exists $opts{F} ) {
  $defaults{msgfile} = $opts{F};
}

# default to "current" directory if no args (to emulate 'cvs ci'
# without args)
@ARGV = qw(.) unless @ARGV;

use File::Basename;
use File::Spec ();

# where to store filenames for handling
my ( %tocommit, @unknown );

for my $file (@ARGV) {
  my ( $filename, $filepath, undef ) = fileparse($file);

  if ( -f File::Spec->catfile( $filepath, qw{CVS Root} ) ) {

    push @{ $tocommit{cvs} }, $file unless $file eq 'CVS';

  } elsif ( -f File::Spec->catfile( $filepath, qw{.svn entries} ) ) {

    push @{ $tocommit{svn} }, $file unless $file eq '.svn';

  } else {
    push @unknown, $file;
  }
}

for my $commit_type ( sort keys %tocommit ) {

  my %tmp = ( %{ $prefs->{commit}->{$commit_type} }, %defaults );
  $tmp{files} = join ' ', @{ $tocommit{$commit_type} };

  # delete "whateveropt" where no "whatever" exists
  for my $option ( keys %tmp ) {
    delete $tmp{$option} if $option =~ /(\w+)opt$/ and not exists $tmp{$1};
  }

  my @command = map {
    s/%{(\w+)}/$tmp{$1}||''/ge;
    defined and $_ ne '' ? $_ : ()
  } split /\s+/, $tmp{exec};

  # for "preview" mode, though this will not show required shell quotes
  # around things like a -m commit message
  unshift @command, 'echo' if exists $opts{n};

  unless ( system(@command) == 0 ) {
    my $exit_status = $? >> 8;
    remark(
      'warning',
      'bad exit status',
      { value => $exit_status, type => $commit_type }
    );
  }
}

if (@unknown) {
  local $" = ',';
  remark( 'warning', 'no method to handle', { files => "@unknown" } );
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam $1)[7] : (getpwuid $<)[7] || $ENV{HOME}
        || remark('error',
             'could not lookup user or HOME not set',
             { file => $_ })
        && exit 99;
     }ex;
  }
  return wantarray ? @_ : "@_";
}

sub load_prefs {
  my $file = shift;

  open my $fh, "< $file"
   or remark( 'error', 'could not load preferences', { file => $file } )
   and exit 101;

  my %prefs;
  my %tmp = %defaults;

  while (<$fh>) {
    s/^\s+//;
    next if /^#/;
    chomp;

    if (/^$/) {
      pref_finish( \%tmp, \%prefs ) if exists $tmp{name};
      %tmp = %defaults;
      next;
    }

    s/\s+$//;

    my ( $k, $v ) = split /\s+/, $_, 2;
    unless ( defined $k and $k =~ /^[\w.-]+$/ and defined $v ) {
      remark(
        'warning',
        'skipping invalid data',
        { file => 'prefs', line => $. }
      );
      next;
    }
    $tmp{$k} = $v;
  }
  pref_finish( \%tmp, \%prefs ) if exists $tmp{name};

  return \%prefs;
}

sub pref_finish {
  my $tmp   = shift;
  my $prefs = shift;

  $prefs->{ $tmp->{class} }->{ $tmp->{name} } = {%$tmp};
}
