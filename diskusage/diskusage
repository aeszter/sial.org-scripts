#!/usr/bin/perl
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# 'du' output parser and recorder for tracking disk usage over time.
#
# Run perldoc(1) on this script for additional documentation.

# KLUGE humanize on file size assumes -k set, split for exec-as-list
# will break quoted "-o 'foo bar'" options (minimal risk)
my @du_cmd = split /\s+/, $ENV{DU_CMD} || 'du -k';

# regex to parse output of du with
my $du_re = qr/^(\d+) \s+ (\S+)/ox;

use Getopt::Std;
my %opts;
getopts 'h?c:o:d:', \%opts;

print_help() unless exists $opts{c} and -f $opts{c};
print_help() if exists $opts{h} or exists $opts{'?'};

my $output_tmpl = '%{size} %{path}\n';
$output_tmpl = $opts{o} if exists $opts{o};
$output_tmpl =~ s/(\\.)/qq!"$1"!/eeg;

my %defaults;
if ( exists $opts{d} ) {
  my @pairs = split /(?<!(?<!\\)\\) /, $opts{d};
  for my $token (@pairs) {
    my ( $k, $v ) = $token =~ m/^ \s* ([\w.-]+) = (.*) /x;
    $defaults{$k} = $v if defined $k;
  }
}

open PREFS, "< $opts{c}"
 or remark( 'error', 'could not load prefs', { file => $opts{c}, errno => $! } )
 and exit 104;

while (<PREFS>) {
  next if /^\s*$/;
  s/^\s+//;
  next if /^#/;
  chomp $line;
  s/\s+$//;

  # extend lines ending with \
  if (s/ \\ $ //x) {
    $_ .= <DATA>;
    redo unless eof;
  }

  my @tokens;
 UBLE: {
    # unquoted text
    push( @tokens, $1 ), redo UBLE
     if m/ \G ( [^"'\s]+ ) \s* /cgx;

    # single or double quoted, allowing for backslashed internal escapes
    push( @tokens, $2 ), redo UBLE
     if m/ \G (['"]) ((?: \\.|[^\\\1] )+) \1 \s* /cgx;

    last UBLE if / \G $ /gcx;
  }

  if (@tokens) {
    # unescape things like "\ " or "\n"
    @tokens = map { s/(\\.)/qq!"$1"!/eeg; $_ } @tokens;

    my $dir = shift @tokens;

    # TODO only subpath matching for output right now, could add more
    my @wanted;

    # default to printing for the parentdir, which has no subpath
    push @wanted, { subject => 'subpath', value => '^$', op => 're' };

    for (@tokens) {
      # convert regex-free configuration entries to regex for cleaner
      # configuration file format
      unless ( m,\$$, or m,^\^, ) {
        $_ = '^/' . $_ . '$';
      }
      s, \* ,[^/]+/?,gx;
      push @wanted, { subject => 'subpath', value => $_, op => 're' };
    }

    rundu( $dir, \@wanted );
  }
}

sub rundu {
  my $parentdir = shift;
  my $wanted    = shift;

  # trailing slashes lead to // in output, so evict
  $parentdir =~ s, /+$ ,,x;

  my $targetdir = $parentdir;

  # KLUGE du will happily stat only a symlink instead of the actual
  # target directory
  #
  # TODO warn about this and just change the parentdir?
  $targetdir = readlink $parentdir if -l $parentdir;

  unless ( -d $targetdir ) {
    remark( 'error', 'target not a directory', { dir => $parentdir } );
    exit 101;
  }

  open FROMDU,      '-|'
   or exec @du_cmd, $targetdir
   or remark( 'error', 'du failed', { errno => $!, dir => $parentdir } )
   and exit 102;

  my %dudefaults = ( %defaults, parentdir => $parentdir, epoch => time );

  while (<FROMDU>) {
    chomp;

    # gather output into a hash for easy access of data
    my %duinfo = (%dudefaults);
    unless ( ( $duinfo{size}, $duinfo{path} ) = m/$du_re/ ) {

      # this should never be hit, unless output format of du changes
      remark(
        'error',
        'invalid output from du',
        { line => $., dir => $parentdir }
      );
      exit 103;
    }

    # determine path excluding leading root
    $duinfo{subpath} = '';
    my $offset = index $duinfo{path}, $parentdir;
    if ( $offset > -1 ) {
      $duinfo{subpath} = substr $duinfo{path}, $offset + length $parentdir;
    }

    # KLUGE this assumes 'du -k' is being used!
    $duinfo{humansize} = humanize( $duinfo{size}, { base => 1024 } )
     if $output_tmpl =~ m/%{humansize}/;

    for my $entry (@$wanted) {
      if ( $duinfo{ $entry->{subject} } =~ m/$entry->{value}/ ) {
        my $str_out = $output_tmpl;
        $str_out =~ s/ %{ (\w+) } / defined $duinfo{$1} ? $duinfo{$1} : '' /egx;
        print $str_out;
        last;
      }
    }
  }

  close FROMDU
   or remark(
    'warning',
    'problem closing pipe from du',
    { errno => $!, dir => $parentdir }
   );
}

# Inspired from GNU's df -h output, which fixes 133456345 bytes
# to be something human readable.
#
# takes a number, returns formatted string.  Optionally accepts
# hash reference containing non-standard defaults.
sub humanize {
  my $num   = shift;
  my $prefs = shift;

  # error checking on input...
  return $num unless $num =~ m/^-?\d+$/;

  # various parameters that adjust how the humanization is done
  # these really should be able to be specified on the command line, or
  # read in from a prefs file somewhere, as nobody will agree as to what
  # "proper" human output should look like... :)
  my %defaults = (

    # base numbers are in (1 is bytes, 1024 for K)
    'base' => 1,

    # include decimals in output? (e.g. 25.8K vs. 26K)
    'decimal' => 1,

    # include .0 in decmail output?
    'decimal_zero' => 1,

    # what to divide file sizes down by
    # 1024 is generally "Kilobytes," while 1000 is
    # "kilobytes," technically
    'factor' => 1024,

    # percentage above which will be bumped up
    # (e.g. 999 bytes -> 1 K as within 5% of 1024)
    # set to undef to turn off
    'fudge' => 0.96,

    # lengths above which decimals will not be included
    # for better readability
    'max_human_length' => 2,

    # list of suffixes for human readable output
    'suffix' => [ 'B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y' ],
  );

  # merge passed options with defaults
  while ( my ( $k, $v ) = each %$prefs ) {
    if ( exists $defaults{$k} and $v ) {
      $defaults{$k} = $v;
    }
  }

  # some local working variables
  my $count  = 0;
  my $prefix = '';
  my $tmp    = '';

  # handle negatives
  if ( $num < 0 ) {
    $num    = abs $num;
    $prefix = '-';
  }

  # adjust number to proper base
  $num *= $defaults{'base'};

  # reduce number to something readable by factor specified
  while ( $num > $defaults{'factor'} ) {
    $num /= $defaults{'factor'};
    $count++;
  }

  # optionally fudge "near" values up to next higher level
  if ( $defaults{'fudge'} ) {
    if ( $num > ( $defaults{'fudge'} * $defaults{'factor'} ) ) {
      $count++;
      $num /= $defaults{'factor'};
    }
  }

  # no .[1-9] decimal on longer numbers for easier reading
  # only show decimal if format say so
  if ( length sprintf( "%.f", $num ) > $defaults{'max_human_length'}
    || !$defaults{'decimal'} ) {

    $tmp = sprintf( "%.0f", $num );

    } else {
    $tmp = sprintf( "%.1f", $num );

    # optionally hack trailing .0
    $tmp =~ s/\.0$// unless $defaults{'decimal_zero'};
  }

  return $prefix . $tmp . $defaults{'suffix'}->[$count];
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}

sub print_help {
  print <<"HELP";
Usage: $0 -c configfile [-o outputtemplate] [-d defaults]

'du' output parser and recorder for tracking disk usage over time.

Options:
  -h/-?  Display this message.

  -c xx  Load required configuration file from stated file.

  -o oo  Use custom output template.

  -d dd  Specify additional default key=value pairs for output template.

Run perldoc(1) on this script for additional documentation.

HELP
  exit 100;
}

__END__

# TODO write POD

  /home/jmates src/* backup cfm co repository
  /sial/music *
