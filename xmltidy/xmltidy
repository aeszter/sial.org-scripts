#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Cleans up XML via the xmllint utility from the libxml2 project.
# Handles input either from standard input, or named files given as
# arguments. Named files are currently operated on in-place, while
# standard input is passed to standard out after the tidy is done.

use strict;

# command to tidy up XML; xmllint from libxml2 accepts the filename on
# the command line and produces output to standard out
my @xmltidy_cmd = qw(xmllint --nsclean --encode utf8 --format);

use File::Basename qw(basename dirname);
use File::Temp qw(tempfile);

my $basename = basename $0;

# TODO use these
use Getopt::Std;
my %opts;
getopts 'h?i', \%opts;

# to preserve any $! from the tidy command out of a function call
my $error;

# no args, read file from stdin, write to temp file
unless (@ARGV) {
  my ( $fh, $tmpfile ) = tempfile( UNLINK => 1 );
  print $fh $_ while <STDIN>;

  my $tfh = xmltidy($tmpfile);
  unless ($tfh) {
    remark( 'error', 'xmllint failed', { errno => $error } );
    exit 101;
  }
  print while <$tfh>;

} else {
  for my $file (@ARGV) {
    next unless -f $file;

    # KLUGE transfer permissions from file to temporary file
    my ($filemode) = ( stat _ )[2] & 07777;

    my $tfh = xmltidy($file);
    unless ($tfh) {
      remark( 'error', 'xmllint failed', { errno => $error, file => $file } );
      exit 101;
    }

    # read document to scalar as otherwise while() loop over $tfh has
    # issues when writing to temporary file... buffering problems?
    my $string = do { local $/ = undef; <$tfh> };
    if ( length $string == 0 ) {
      remark( 'error', 'no data from xmllint', { file => $file } );
      exit 102;
    }

    my $parentdir = dirname $file;
    my ( $replacefh, $tmpfile ) =
     tempfile( ".tmp-$basename.XXXXXXX", DIR => $parentdir, UNLINK => 0 );

    print $replacefh $string;

    close $replacefh
     or remark(
      'error',
      'problem closing filehandle',
      { errno => $!, file => $tmpfile }
     )
     and exit 103;

    # KLUGE fix mode
    chmod $filemode, $tmpfile;

    rename $tmpfile, $file
     or remark(
      'warning',
      'rename failed',
      { errno => $!, source => $tmpfile, target => $file }
     );
  }
}

# accepts filename to tidy up, returns filehandle to play with
sub xmltidy {
  my $tmpfile = shift;

  undef $error;

  open my $tidyfh,       "-|"
   or exec @xmltidy_cmd, $tmpfile
   or $error = $!;

  return $tidyfh;
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$basename $priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}

END {
  # catch disk full problems during command line redirection according
  # to perlopentut
  close STDOUT
   or remark( 'error', 'could not close STDOUT', { errno => $! } )
   and exit 104;
}
