#!/usr/bin/perl -w
#
# $Id$
#
# Utility to handle Portable Shogi Notation (.psn) data. At present,
# PSN data is loaded into a PostgreSQL database, assuming appropriate
# tables exist:
#
# psn-util dbconv japan-isf-2005.psn
#
# See end of file for PostgreSQL schema.

use strict;

use File::Basename qw(basename);

use DBIx::Simple  ();
use SQL::Abstract ();
my $DATA_SOURCE = 'dbi:Pg:dbname=shogi';

# TODO support nested move variations: removed for now with this gem
# from MRE 2nd edition
my $NESTED_PAREN_RE;
$NESTED_PAREN_RE = qr/ \( ( [^()] | (??{ $NESTED_PAREN_RE }) )* \) /x;

# TODO support reading comments into the database. Strip them from the
# moves list for now.
my $NESTED_CURLY_RE;
$NESTED_CURLY_RE = qr/ \{ ( [^{}] | (??{ $NESTED_CURLY_RE }) )* \} /x;

my %modes = ( 'dbconv' => \&dbconv );

my $mode = shift;
die "Usage: $0 dbconv file1 [.. fileN]\n"
  if not defined $mode
  or not exists $modes{$mode};
$modes{$mode}->(@ARGV);

sub dbconv {
  my $db =
    DBIx::Simple->connect( $DATA_SOURCE, '', '',
    { AutoCommit => 1, RaiseError => 1 } );
  $db->abstract = SQL::Abstract->new();

  for my $filename (@ARGV) {
    open my $fh, '<', $filename
      or die "error: could not open file: name=$filename, errstr=$!\n";

    # link games to file they came from
    $db->insert( 'files', { name => basename($filename) } );
    my $file_id = $db->last_insert_id( undef, undef, 'files', undef );

    parse_file( $db, $fh, $file_id );
  }

  return;
}

sub parse_file {
  my $db      = shift;
  my $fh      = shift;
  my $file_id = shift;

  my %game;    # buffer for current game being parsed
  my $in_moves_section = 0;

  while ( my $line = <$fh> ) {

    # Catch player name, other metadata above moves section
    if ( $line =~ m/^\[ (\S+) \s " ([^"]+) "\]/x ) {

      # If still in a moves section, assume this new entry marks a new
      # game and handle the old one
      if ( $in_moves_section and keys %game ) {
        handle_game( $db, $file_id, \%game );
        %game             = ();
        $in_moves_section = 0;
      }

      $game{ lc $1 } = $2;

    } else {
      $in_moves_section = 1;

      # Convert moves section into string parsed later
      $game{_moves} .= $line;
    }
  }

  # Cleanup if run off end of file
  if ( keys %game ) {
    handle_game( $db, $file_id, \%game );
  }

  return;
}

sub handle_game {
  my $db       = shift;
  my $file_id  = shift;
  my $game_ref = shift;

  warn "info: loading game";

  $game_ref->{_moves} =~ s/\s+/ /g;
  $game_ref->{_moves} =~ s/^\s+//g;
  $game_ref->{_moves} =~ s/\s+$//g;

  # TODO parse move variations and comments instead of evicting them
  $game_ref->{_moves} =~ s/$NESTED_PAREN_RE//g;
  $game_ref->{_moves} =~ s/$NESTED_CURLY_RE//g;

  my @moves =
    grep { defined and $_ ne '' }
    split /\s+\d+\.|\s+(?!\d\.)/, $game_ref->{_moves};
  $moves[0] =~ s/^1\.//;
  $game_ref->{_move_list} = \@moves;

  # TODO convert "date" into TIMESTAMP (or make a reasonable attempt thereof)
  #  $game_ref->{_date} =
  # TODO how set the database date format properly, depending on the
  # date template (if any) used here??

  my @game_fields =
    qw{sente sentegrade gote gotegrade date event venue round result moves _moves handicap};
  my $game_id;

  eval {
    $db->insert( 'games',
      { ( map { $_, $game_ref->{$_} } @game_fields ), file_id => $file_id } );
    $game_id = $db->last_insert_id( undef, undef, 'games', undef );
  };
  if ($@) {
    use Data::Dumper;
    warn Dumper $game_ref;
    die $@;
  }

  my $move_number = 1;
  for my $move_text ( @{ $game_ref->{_move_list} } ) {
    $db->insert(
      'moves', {
        move_number => $move_number,
        move_text   => $move_text,
        game_id     => $game_id
      }
    );
    $move_number++;
  }

}

__END__

createdb -E UTF8 shogi


CREATE TABLE files (
  file_id SERIAL PRIMARY KEY,
  name VARCHAR(255),
  url TEXT
);

CREATE TABLE games (
  game_id SERIAL PRIMARY KEY,

  file_id INT,
  FOREIGN KEY (file_id) REFERENCES files ON UPDATE CASCADE ON DELETE NO ACTION,
  
  sente VARCHAR(255),
  sentegrade VARCHAR(32),
  gote VARCHAR(255),
  gotegrade VARCHAR(32),
  date VARCHAR(255),
  event VARCHAR(255),
  venue VARCHAR(255),
  round VARCHAR(32),
  result VARCHAR(32),
  handicap VARCHAR(255),
  
  moves INT,
  _moves TEXT,
  
  -- for conversion of date
  _date TIMESTAMP,
  
  -- for {blah blah...} text prior to the move list starting
  game_comment TEXT
);

-- RAV (recursive alternative variations?) not supported (would need branch_id
-- that otherwise defaults to 1?)
CREATE TABLE moves (
  move_id SERIAL PRIMARY KEY,
  
  move_number INT,
  move_text VARCHAR(8),
  
  game_id INT,
  FOREIGN KEY (game_id) REFERENCES games ON UPDATE CASCADE ON DELETE CASCADE,
  
  -- for {blah blah...} text inside moves section
  move_comment TEXT
);
