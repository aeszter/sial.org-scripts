#!/usr/bin/perl -wT
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Lists new (unseen) files found under the specified directories.
#
# Run perldoc(1) on this script for additional documentation.

use strict;

use Digest::SHA1 ();
my $ctx = Digest::SHA1->new;

use File::Basename qw(basename fileparse);
use File::Find qw(find);
use Time::Local ();
use YAML        ();

my $basename = basename $0;

use Getopt::Std;
my %opts;
getopts 'h?s:w:T', \%opts;
print_help() if $opts{h} or $opts{'?'} or not @ARGV or not exists $opts{s};

# sanitize search directories specified
my @dirs = untaintpath(@ARGV);
unless (@dirs) {
  remark( 'error', 'no search directories following taint check' );
  exit 101;
}
if ( @dirs != @ARGV ) {
  remark( 'warning',
       'removed '
     . ( scalar @ARGV - scalar @dirs )
     . ' tainted search directory from argument list' );
}

# load and prepare seen index
my $seen_file = untaintpath( $opts{s} );
unless ( defined $seen_file ) {
  remark( 'error', 'could not untaint seen filename' );
  exit 102;
}

my $seen = {};
if ( -f $seen_file ) {
  eval { $seen = YAML::LoadFile $seen_file; };
  if ($@) {
    chomp $@;
    # TODO YAML dumps errors in YAML, which is non ideal for my "want a
    # quick something is wrong" message purposes
    remark(
      'error',
      'could not load index',
      { file => $seen_file, errno => $@ }
    );
    exit 105;
  }
}

# find date ranges for new files to skip (-T "today") or files older
# than allowed by the -w "window" option
my $midnight = Time::Local::timelocal( qw(0 0 0), (localtime)[ 3 .. 5 ] );
my $window = ( $midnight || $^T ) - duration2seconds( $opts{w} || '2w' );
undef $midnight unless $opts{T};

# throw out older entries from seen data
for my $key ( keys %$seen ) {
  delete $seen->{$key} if $seen->{$key}->{mtime} < $window;
}

# look for files
find { wanted => \&process, no_chdir => 1 }, @dirs;

# update seen index
eval { YAML::DumpFile $seen_file, $seen; };
if ($@) {
  chomp $@;
  remark( 'error', 'could not save index',
    { file => $seen_file, errno => $@ } );
  exit 106;
}

exit;

# File::Find file handler
sub process {
  return unless -f;

  my %filedata;

  # skip logfiles outside of processing window by modification time
  $filedata{mtime} = ( stat _ )[9];
  return if $filedata{mtime} < $window;

  # skip files modified today if needed
  if ($midnight) {
    return if $filedata{mtime} > $midnight;
  }

  # untaint filename (paranoia)
  unless ( $filedata{filename} = untaintpath($_) ) {
    remark( 'error', 'could not untaint filename', { file => $_ } );
    exit 103;
  }

  # skip files with no digest, or a digest already seen
  $filedata{digest} = filedigest( $filedata{filename} );

  unless ( defined $filedata{digest} ) {
    remark(
      'notice',
      'skipping as no checksum',
      { file => $filedata{filename} }
    );
    return;
  }
  if ( exists $seen->{ $filedata{digest} } ) {
    # TODO options to control log verbosity?
    #    remark(
    #      'info',
    #      'skipping as already seen',
    #      { file => $filedata{filename} }
    #    );
    return;
  }

  # various path information for future processing
  #( $filedata{file}, $filedata{dirname} ) = fileparse($_);

  # just print full filename
  # TODO template output for more flexbility?
  print $filedata{filename}, "\n";

  # update seen record with selected file data
  # TODO also store tag names for different utilities?
  $seen->{ $filedata{digest} } =
   { map { $_ => $filedata{$_} } qw(filename mtime) };
}

# untaints data, restricts what filenames may contain. Accepts 1 or more
# file paths, returns undef or 1 or more paths depending on the results
# of the tests.
sub untaintpath {
  my @paths = map {

    # limit to allowed characters, skip names with ../.. runs
    m,^([A-Za-z0-9_./-]+)$,;
    ( defined $1 and $1 eq $_ ) ? ( not m{\Q../..} ) ? $1 : () : ();

  } @_;

  return wantarray ? @paths : $paths[0];
}

# takes filename, returns sha1 digest of file contents using
# global object
sub filedigest {
  my $file = shift;

  unless ( open FILE, "< $file" ) {
    remark( 'warning', 'could not open file', { file => $file, errno => $! } );
    return;
  }
  binmode FILE;

  # b64digest method resets object, so can reuse
  my $digest = $ctx->addfile(*FILE)->b64digest;

  close FILE;
  return $digest;
}

# for logging things
sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift || {};

  chomp $message;

  my $attr_str;
  if ( keys %$attributes ) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;

    # escape wacky characters to avoid messing up things
    $attr_str =~ s/ ( [^[:print:]\t] ) / sprintf "\\%03o", ord $1 /egx;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";

  return 1;
}

# takes duration such as "2m3s" and returns number of seconds.
sub duration2seconds {
  my $tmpdur = shift;
  my $seconds;

  # how to convert short human durations into seconds
  my %factor = (
    w => 604800,
    d => 86400,
    h => 3600,
    m => 60,
    s => 1,
  );

  # assume raw seconds for plain number
  if ( $tmpdur =~ m/^\d+$/ ) {
    $seconds = $tmpdur * 60;

  } elsif ( $tmpdur =~ m/^[wdhms\d\s]+$/ ) {

    # match "2m 5s" style input and convert to seconds
    while ( $tmpdur =~ m/(\d+)\s*([wdhms])/g ) {
      $seconds += $1 * $factor{$2};
    }
  } else {
    remark( 'error', 'unknown characters in duration',
      { duration => $tmpdur } );
    exit 104;
  }

  unless ( defined $seconds and $seconds =~ m/^\d+$/ ) {
    remark( 'error', 'unable to parse duration', { duration => $tmpdur } );
    exit 104;
  }

  return $seconds;
}

# clean up env for taint mode ("perldoc perlsec" for more information)
sub BEGIN {
  delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
  $ENV{PATH} = '/bin:/usr/bin';
}

# a generic help blarb
sub print_help {
  print <<"HELP";
Usage: $basename [options] [-s seen-index] directory [directory ...]

Lists new (unseen) files under specified directory(-ies).

Options supported:

  -h/-?  Display this message.

  -s ss  Path to list of previously seen filenames index.

  -w dd  Window inside which files will be considered against index.
  -T     Skip files modified today.

Run perldoc(1) on this script for additional documentation.

HELP
  exit 100;
}

__END__

=head1 NAME

unseen - lists unseen files under specified directories

=head1 SYNOPSIS

List unseen files under /var/log/archive new within the last
three weeks, using /var/log/archive.seen as seen archive file.

  $ unseen -w 3w -s /var/log/archive.seen /var/log/archive

=head1 DESCRIPTION

=head2 Overview

For listing unseen files under directory trees. Written to handle case
of finding unprocessed logfiles (limited numbers of files) under log
directories for passing to swatch and other utilities.

Files are recorded as seen with aid of a seen file, which is indexed
by the SHA1 digest of the file contents. A processing window option
configures how far back in time the script is allowed to report on,
to keep the index file and SHA1 digest generation needs from growing
over time.

As a consequence of the SHA1 digest, the script will list both files
that are new to the search directory, or ones that have been modified
since the previous run of the script.

Without the seen index file, the script will always list all files under
the specified search directories.

=head2 Normal Usage

  $ unseen [options] [-s seen-index] directory [directory ...]

See L<"OPTIONS"> for details on the command line switches supported.

Either a single or multiple search directories can be specified;
directories will be searched recursively for regular files.

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note about the script.

=item B<-s> I<seenfile>

Path to load seen file data from, or save to after listing the unseen
files for the run in question.

=item B<-w> I<duration>

Prevents files older than midnight minus I<duration> from being
considered with SHA1 checksum comparisons against the seen file
index. The duraction can either be in raw seconds or a short-hand
"2m5s" format.

The default is to skip files older than two weeks. Should the script
fail to calculate midnight, the script launch time will be used.

=item B<-T>

Skip files modified after midnight (00:00) of current day. Good for
excluding active logfiles, assuming daily rotation.

=back

=head1 SECURITY

Taint mode is enabled by default. The script will die if the I<seenfile>
or supplied directories fail an untaint check.

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No known bugs.

=head1 SEE ALSO

perl(1)

=head1 AUTHOR

Jeremy Mates, http://sial.org/contact/

=head1 COPYRIGHT

The author disclaims all copyrights and releases this script into the
public domain.

=head1 VERSION

  $Id$

=head1 SCRIPT CATEGORIES

Utilities
UNIX/System_administration

=cut
