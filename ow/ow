#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into
# the public domain.
#
# Command line URL shortcuts and directory to URL mapping.
#
# TODO means to tab complete on dir/shortcuts? -o flag to choose what
# output mode used (print, OmniWeb script, lynx, etc)?

use URI;

# read method from env if possible (allows easy override)
my $default_open = $ENV{'OW_METHOD'} || 'lynx';

# what to launch URLs with (but see sub visit below)
# TODO some means to pass options to say lwp-request and wget types?
my %open = (
  lynx          => [qw(lynx)],
  links         => [qw(links)],
  open          => [qw(open)],
  omniweb       => [qw(open -a OmniWeb)],
  safari        => [qw(open -a Safari)],
  'omniweb-bg'  => \&open_omniweb_bg,
  mozilla       => [qw(mozilla)],
  lwp           => [qw(lwp-request)],
  'lwp-noproxy' => [qw(lwp-request -P)],
  wget          => [qw(wget)],
);

my %pfiles = (
  shortcuts => '~/.ow/shortcuts',
  dirmap    => '~/.ow/dirmap',
);

# parse command-line options
use Getopt::Std;
my (%opts);
getopts( 'dlo:T:', \%opts );

for ( keys %pfiles ) {
  $pfiles{$_} = tilde_expand( $pfiles{$_} );
}

# -d flag does directory->web map lookup (if possible)
if ( exists $opts{'d'} ) {
  my $dirmap = loadconfig( $pfiles{'dirmap'} );

  require Cwd;

  if ( @ARGV == 1 and $ARGV[0] eq '-' ) {
    chomp( @ARGV = <STDIN> );
  }

  my @dir;
  if (@ARGV) {
    @dir = map { Cwd::abs_path($_) } grep -d, @ARGV;
  }

  # default to current directory
  push @dir, Cwd::getcwd() unless @dir;

  for my $dir (@dir) {

    my $got_url = 0;

    # longest first, so subdirs can override parent
    for ( sort { length $b <=> length $a } keys %$dirmap ) {

      my $pos = index $dir, $_;
      if ( $pos > -1 ) {
        my $frag = substr( $dir, $pos + length $_ ) || '';
        $frag .= "/";

        # prevent // issues
        $frag =~ s,^/+,, if $dirmap->{$_} =~ m,/%[@\d],;
        $dirmap->{$_} =~ s,%(\@|\d+)/,%$1,g if $frag eq '';

        visit( expand( $dirmap->{$_}, [$frag] ) );
        $got_url = 1;
      }
    }

    warn "notice: no map for $dir\n" unless $got_url;
  }

  exit;
}

my $scuts = loadconfig( $pfiles{'shortcuts'} );

# for _T_ab completion lookups on hash keys
if ( exists $opts{'T'} ) {
  if ( $opts{'T'} eq 'open' ) {
    print join "\n", sort keys %open;
  } elsif ( $opts{'T'} eq 'shortcuts' ) {
    # need to cut out the "*" and "google@" stuff
    my %seen;
    @seen{ map { /(\w+)/ } keys %$scuts } = ();
    print join "\n", sort keys %seen;
  }
  print "\n";
  exit;
}

if (@ARGV) {
  parse_sc( [ \@ARGV ] );
} else {
  my $scs;
  while (<STDIN>) {
    chomp;
    push @$scs, [split];
  }
  parse_sc($scs);
}

sub parse_sc {
  my $sc = shift;

  for (@$sc) {
    if ( @$_ == 1 ) {
      if ( exists $scuts->{ $_->[0] } ) {

        # assume vanilla shortcuts are urls...
        visit( $scuts->{ $_->[0] } );

      } elsif ( $_->[0] =~ m(^\w+://.) ) {

        # visit url-ish resources directly
        visit( $_->[0] );

      } elsif ( $_->[0] =~ m/\./ ) {

        visit( 'http://' . $_->[0] );

      } elsif ( exists $scuts->{'*'} ) {

        # * shortcut is for unmatched things, an example target would be
        # http://www.%@.com/ to expand input to .com websites
        visit( expand( $scuts->{'*'}, $_ ) );

      } else {
        die "not sure what to do with: $_->[0]\n";
      }
    } else {
      my $key = shift @$_;

      # shortcut names with parameters have a trailing @ on them,
      # but user should not type that
      $key .= '@';

      # TODO check if two args whether second is actually a http:// URL,
      # which should get fed to direct lookup instead of google search
      # perhaps?
      if ( exists $scuts->{$key} ) {
        visit( expand( $scuts->{$key}, $_ ) );
      } else {
        die "no such shortcut: $key\n";
      }
    }
  }
}

# takes URL pattern "http://www.%@.com/" and an array reference to insert
# into said pattern.  Returns expanded string.
sub expand {
  my $pattern = shift;
  my $terms   = shift;

  $pattern =~ s/\Q%@/join '+', @$terms/ge;
  $pattern =~ s/%(\d+)/$terms->[$1-1]||''/ge;

  my $url = URI->new($pattern)->canonical;

  warn "notice: could not convert to URL: $url\n" unless $url;
  return $url;
}

# expects URL to visit, handles lanuching what OS needs.
sub visit {
  my $url = shift;
  return unless $url;

  if ( exists $opts{'l'} ) {
    print $url, "\n";
    return;
  }

  my $method = exists $opts{'o'} ? $opts{'o'} : $default_open;
  die "error: unknown open method: $method\n" unless exists $open{$method};

  # TODO dispatch table for this
  if ( ref $open{$method} eq 'ARRAY' ) {

    # TODO error checking
    system @{ $open{$method} }, $url;
  } else {
    $open{$method}->($url);
  }
}

sub open_omniweb_bg {
  my $url = shift;

  # for Mac OS X, use AppleScript to open pages in background, as
  # open(1) brings to foreground.
  my $omniweb_open_script = <<EOF;
set new_url to "$url"

tell application "OmniWeb"
        -- this closes windows referencing what we are opening to avoid
        -- having multiple windows open to the same URL
        repeat with win_id in ListWindows
                set win_url to first item of (GetWindowInfo of win_id)
                if win_url is equal to new_url then
                        close window (index of window id win_id)
                end if
        end repeat

        OpenURL new_url
end tell
EOF

  # TODO error checking!
  # TODO better handling of annoying output from osascript
  close STDOUT;
  open OSASCRIPT, "|-"
   or exec 'osascript'
   or die "problem with osascript: $!";
  print OSASCRIPT $omniweb_open_script;
  close OSASCRIPT;

  return;
}

sub tilde_expand {
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam($1))[7] : ( $ENV{'HOME'} || $ENV{'LOGDIR'} )
     }ex;
  }
  return wantarray ? @_ : "@_";
}

# accepts filename to load TSV from, returns hash reference
sub loadconfig {
  my $f = shift;
  my $h;

  open F, "< $f" or die "error: unable to open $f: $!\n";
  while (<F>) {
    chomp;
    next if /^\s*#/;
    s/\s+$//;
    next if /^$/;

    my ( $k, $v ) = split ' ', $_, 2;
    if ( $k and $v ) {

      # convert tabs in key back to literal, if needed (unlikely)
      $k =~ s/\\t/\t/g;

      $h->{$k} = $v;
    }
  }
  close F or warn "warning: problem closing $f: $!\n";

  return $h;
}
