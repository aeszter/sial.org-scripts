#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into
# the public domain.
#
# Command line URL shortcuts and directory to URL mapping.

use URI;

# what to launch URLs with
my @open = qw(lynx);

if ($^O eq 'darwin') {
  @open = 'open';
}

my %pfiles = (
  shortcuts => '~/.ow/shortcuts',
  dirmap   => '~/.ow/dirmap',
);

# parse command-line options
use Getopt::Std;
my (%opts);
getopts('d', \%opts);

for (keys %pfiles) {
  $pfiles{$_} = tilde_expand($pfiles{$_});
}

# -d flag does directory->web map lookup (if possible)
if (exists $opts{d}) {
  my $dirmap = loadconfig($pfiles{dirmap});

  require Cwd;

  if (@ARGV == 1 and $ARGV[0] eq '-') {
    chomp(@ARGV = <STDIN>);
  }

  my @dir;
  if (@ARGV) {
    @dir = map { Cwd::abs_path($_) } grep -d, @ARGV;
  }
  
  # default to current directory
  push @dir, Cwd::getcwd() unless @dir;

  for my $dir (@dir) {
    # longest first, so subdirs can override parent
    for (sort { length $b <=> length $a } keys %$dirmap) {

      my $pos = index $dir, $_;
      if ($pos > -1) {
        my $frag = substr($dir, $pos + length $_) || '';
        $frag .= "/";
        
        # prevent // issues
        $frag =~ s,^/+,, if $dirmap->{$_} =~ m,/%[@\d],;
        $dirmap->{$_} =~ s,%(\@|\d+)/,%$1,g if $frag eq '';

        visit(expand($dirmap->{$_}, [$frag]));
      }
    }
  }

  exit;
}

my $scuts = loadconfig($pfiles{shortcuts});

if (@ARGV) {
  parse_sc([\@ARGV]);
} else {
  my $scs;
  while (<STDIN>) {
    chomp;
    push @$scs, [split];
  }
  parse_sc($scs);
}

sub parse_sc {
  my $sc = shift;

  for (@$sc) {
    if (@$_ == 1) {
      if (exists $scuts->{$_->[0]}) {
    
        # assume vanilla shortcuts are urls...
        visit($scuts->{$_->[0]});
    
      } elsif ($_->[0] =~ m(^\w+://.)) {
    
        # visit url-ish resources directly
        visit($_->[0]);
    
      } elsif ($_->[0] =~ m/\./) {
    
        visit('http://' . $_->[0]);
    
      } elsif (exists $scuts->{'*'}) {
    
        # * shortcut is for unmatched things, an example target would be
        # http://www.%@.com/ to expand input to .com websites
        visit(expand($scuts->{'*'}, $_));
    
      } else {
        die "not sure what to do with: $_->[0]\n";
      }
    } else {
      my $key = shift @$_;
    
      # shortcut names with parameters have a trailing @ on them,
      # but user should not type that
      $key .= '@';
    
      # TODO check if two args whether second is actually a http:// URL,
      # which should get fed to direct lookup instead of google search
      # perhaps?
      if (exists $scuts->{$key}) {
        visit(expand($scuts->{$key}, $_));
      } else {
        die "no such shortcut: $key\n";
      }
    }
  }
}

# takes URL pattern "http://www.%@.com/" and an array reference to insert
# into said pattern.  Returns expanded string.
sub expand {
  my $pattern = shift;
  my $terms = shift;

    $pattern =~ s/\Q%@/join '+', @$terms/ge;
  $pattern =~ s/%(\d+)/$terms->[$1-1]||''/ge;

  return $pattern;
}

# expects URL to visit, handles lanuching what OS needs.
sub visit {
  my $url = URI->new(shift)->canonical;
  warn "notice: could not parse $url, skipping" unless $url;
  system @open, $url;
}

sub tilde_expand {
  my @tmp;
  for (@_) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam($1))[7] : ( $ENV{HOME} || $ENV{LOGDIR} )
     }ex;
  }
  return wantarray ? @_ : "@_";
}

# accepts filename to load TSV from, returns hash reference
sub loadconfig {
  my $f = shift;
  my $h;
  
  open F, $f or die "error: unable to open $f: $!\n";
  while (<F>) {
    chomp;
    next if /^#/;
    s/^\s+//; s/\s+$//;
    next if /^$/;
    
    my ($k, $v) = split /\t/, $_, 2;
    if ($k and $v) {
      # convert tabs in key back to literal, if needed (unlikely)
      $k =~ s/\\t/\t/g;

      $h->{$k} = $v;
    }
  }
  close F or warn "warning: problem closing $f: $!\n";
  
  return $h;
}
