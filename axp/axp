#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Apply XSL files to XML data via XML::ApplyXSLT module.
#
# Run perldoc(1) on this script for additional documentation.

use strict;

use File::Basename qw(basename fileparse);
use File::Spec ();
my $basename = basename $0;

# what to consider as a filename suffix seperator (all OS I've seen use
# a period, but you never know...)
my $suffix_char = '.';
my $suffix_re   = qr/\./;

my %defaults = ( quiet => 0 );

use Getopt::Std;
my %opts;
getopts 'h?qc:s:P:o:p:', \%opts;
print_help() if $opts{h} or $opts{'?'} or not @ARGV;

# TODO also need some way to read in arbitrary data to defaults hash
#
# TODO might also need a "class.style" so can tab complete against a list?
my %user_default = ();
$user_default{class} = $opts{c} if exists $opts{c};
$user_default{style} = $opts{s} if exists $opts{s};
$user_default{path}  = $opts{P} if exists $opts{P};

$defaults{quiet} = 1 if $opts{q};

my %user_params = ();
if ( exists $opts{p} ) {
  my @pairs = split /(?<!(?<!\\)\\) /, $opts{p};
  for my $token (@pairs) {
    my ( $k, $v ) = $token =~ m/^ \s* ([\w.-]+) = (.*) /x;
    $user_params{$k} = $v if defined $k;
  }
}

# technically optional, but what's the point without these?
my $rules_file = tilde_expand( $ENV{AXP_RULES} || '~/.axp/rules' );
open my $rfh, "< $rules_file"
 or remark(
  'warning',
  'cannot load rules file',
  { file => $rules_file, errno => $! }
 );

my @new_args;
push @new_args, 'rules', $rfh if $rfh;

use XML::ApplyXSLT ();
my $xapply = XML::ApplyXSLT->new(@new_args);

close $rfh if $rfh;

# TODO way to set these
$xapply->config_libxml( { load_ext_dtd => 0 } );

FILE: for my $file (@ARGV) {
  unless ( -e $file ) {
    remark( 'notice', 'skipping as does not exist', { file => $file } )
     unless exists $defaults{quiet};
    next FILE;
  }

  my $doc;
  unless ( $doc = $xapply->parse($file) ) {
    remark(
      'warning',
      'could not parse file',
      { file => $file, errno => $xapply->errorstring }
     )
     unless exists $defaults{quiet};
    next FILE;
  }

  my ( $filedata, $defaults, $params ) = $xapply->study( $doc, $file );

  %$defaults = ( %$defaults, %user_default );
  %$params   = ( %$params,   %user_params );

  my ( $docref, $details ) =
   $xapply->transform( $doc, default => $defaults, param => $params );
  unless ( defined $docref ) {
    remark(
      'error',
      'could not parse document',
      { file => $file, errno => $xapply->errorstring }
    );
    exit 101;
  }

  # TODO need to chdir or similar for the output files?
  my $output_file;
  if ( exists $opts{o} ) {
    ( $output_file = $opts{o} ) =~
     s/ %{ (\w+) } / $filedata->{$1} || $defaults->{$1} || '' /egx;

    # TODO use IO::Atomic or something?
    open OUTPUT, "> $output_file"
     or remark(
      'error',
      'could not write to file',
      { file => $output_file, errno => $! }
     )
     and exit 102;
    select OUTPUT;
  }

  # TODO need autoflush if no newlines on end?
  print $$docref;

  if ( exists $opts{o} ) {
    close OUTPUT
     or remark(
      'error',
      'could not close write to file',
      { file => $output_file, errno => $! }
     )
     and exit 102;
  }
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  my @pathes = @_;
  for (@pathes) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam $1)[7] : (getpwuid $<)[7] || $ENV{HOME}
        || remark('error',
             'could not lookup user or HOME not set',
             { file => $_ })
        && exit 99;
     }ex;
  }
  return wantarray ? @pathes : "@pathes";
}

sub print_help {
  print <<"HELP";
Usage: $basename [options] file [file2 ...]

Apply XSL files to XML data.

Options:
  -h/-?  Display this message.
  -q     Quiet: emit fewer warnings.

  -p pp  Specify XSL parameters as 'key=value key2=value2'

  -c cc  Set document 'class' preference.
  -s ss  Set document 'style' preference.
  -P PP  Set stylesheet path option.

  -o tt  Use a custom file output template.

Run perldoc(1) on this script for additional documentation.

HELP
  exit 100;
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}

__END__

=head1 NAME

axp - apply XSL files to XML data

=head1 SYNOPSIS

Parse document to standard out using ruleset defaults.

  $ axp index.xml

Translate a set of XML documents into HTML files based on the input
filename using C<safari> style.

  $ axp -o '%{file}.html' -s safari *.xml

=head1 DESCRIPTION

=head2 Overview

Command line interface to L<XML::ApplyXSLT>. Assists in transforming XML
data with Extensible Stylesheet Language (XSL) files. Best suited to
cases where many different stylesheet files for various XML formats are
logically laid out on a filesystem, and can be referenced by C<class> or
C<style> statements. For simpler needs, xsltproc(1) from the XSLT C
library for GNOME will be adequate.

At minimum, a C<path> option will need to be set to lookup a XSL file;
more complex needs can be met through macro expansion of C<class> and
C<style> options againt the C<path>, and the use of a ruleset file to
set options based on XML document metadata such as the location on the
filesystem or the root element name.

=head2 Normal Usage

  $ axp [options] file [file2 ...]

See L<"OPTIONS"> for details on the command line switches supported.

Specify one or more XML documents to transform. Output by default goes
to standard out, even for multiple documents. Use the B<-o> option to
save the output to file(s).

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note about the script.

=item B<-q>

Emit fewer warnings.

=item B<-P> I<path-template>

Custom path to stylesheets. Could be static path, if only one
stylesheet exists for a document type, or include C<%{class}> and
C<%{style}> macros to expand depending on document metadata or other
command line options.

  -p '/var/www/htdocs/xsl/%{class}/%{style}.xsl'

Paths should be set in the rules file, so only class and style need to
be altered from the command line. This is because the C<path> option
tends to be static, long, and hard to tab complete.

=item B<-c> I<class>

Sets the C<class> option to be expanded in the C<path> option when
looking up stylesheet files. The C<class> option should be a parent
directory for any number of C<style> files suitable for transforming the
XML format in question.

=item B<-s> I<style>

Sets the C<style> option to be expanded in the C<path> option when
looking up stylesheet files. Should represent a filename. Different
styles allows particular XML document format classes to be rendered in
different ways, such as different HTML for different web browsers.

=item B<-o> I<output-template>

Normally all output is to standard out. This option directs output to a
file. To create one output file for each input XML document, use a
template format that will be expanded using the file metadata (C<file>,
C<dirname>) or preference data (C<class>, C<style>). For instance, to
create a C<doc.html> from a C<doc.xml> input filename, use:

  -o '%{file}.html'

=item B<-p> I<parameters>

Read XSL parameters to be used in the document transformation.
Specify as a space seperated list of key=value pairs. Use "\ " if a
literal space is needed; backslash expansion will also allow the use
of \n for a newline and similar.

=back

=head1 RULES

The C<rules> file is parsed into an internal format, then used to
determine whether to handle a file and if so what options to set.
The current ruleset language is simplistic and subject to change
without notice.

  defaults: path=/var/www/htdocs/xsl/%{class}/%{style}.xsl style=default

  # differnt style repository for different website
  dirname sub "var/www/othersite" \
    path=/var/www/othersite/_xs/%{class}/%{style}.xsl style=default

  # class and style defaults for following types
  rootname eq "eolas" stop class=eolas
  rootname eq "changelog" stop class=cvs2cl

  doctype eq "-//OASIS//DTD DocBook XML V4.2//EN" stop class=docbook42

=head1 BUGS

=head2 Reporting Bugs

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No way to specify certain configuration options, or pass XSL parameters.
See source for TODO and other comments. Probably a lot of other things
that can be improved, due to this tool being new.

=head1 SEE ALSO

perl(1), XML::ApplyXSLT, XML::LibXML, XML::LibXSLT

The Extensible Stylesheet Language (XSL) specification:

http://www.w3.org/TR/xsl/

=head1 AUTHOR

Jeremy Mates, http://sial.org/contact/

=head1 COPYRIGHT

The author disclaims all copyrights and releases this script into the
public domain.

=head1 VERSION

  $Id$

=cut
