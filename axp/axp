#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Applies XSLT styleseets to XML data.
#
# Run perldoc(1) on this script for additional documentation.

use strict;

use File::Basename qw(basename fileparse);
use File::Spec ();
my $basename = basename $0;

# what to consider as a filename suffix seperator (all OS I've seen use
# a period, but you never know...)
my $suffix_char = '.';
my $suffix_re   = qr/\./;

# TODO load from file?
my %defaults = ( quiet => 1 );

use Getopt::Std;
my %opts;
getopts 'h?c:s:p:o:', \%opts;
print_help() if $opts{h} or $opts{'?'} or not @ARGV;

my %user_prefs;
$user_prefs{class} = $opts{c} if exists $opts{c};
$user_prefs{style} = $opts{s} if exists $opts{s};
$user_prefs{path}  = $opts{p} if exists $opts{p};

# TODO read param from user somehow
my %param = ();

my $rules_file = tilde_expand( $ENV{AXP_RULES} || '~/.axp/rules' );
open my $rfh, "< $rules_file"
 or remark(
  'error',
  'cannot load rules file',
  { file => $rules_file, errno => $! }
 )
 and exit 103;

use XML::ApplyXSLT ();
my $xapply = XML::ApplyXSLT->new(rules => $rfh, prefs =>
  { path => '/home/jmates/co/sial.org/htdocs/_xs/%{class}/%{style}.xsl' } );

close $rfh;

# TODO way to set these
$xapply->config_libxml( { load_ext_dtd => 0 } );

# TODO
#my $prefs_file = $ENV{AXPCONF} || '~/.axp/prefs';
#$prefs_file = tilde_expand($prefs_file);
#my $data = load_prefs($prefs_file);

FILE: for my $file (@ARGV) {
  unless ( -e $file ) {
    remark( 'notice', 'skipping as does not exist', { file => $file } )
     unless exists $defaults{quiet};
    next FILE;
  }

  my $doc;
  unless ( $doc = $xapply->parse($file) ) {
    remark(
      'warning',
      'could not parse file',
      { file => $file, errno => $xapply->errorstring }
     )
     unless exists $defaults{quiet};
    next FILE;
  }

  my ( $filedata, $rule_prefs ) = $xapply->study( $doc, $file );

  %$rule_prefs = ( %$rule_prefs, %user_prefs );

  my ( $docref, $details ) =
   $xapply->transform( $doc, prefs => $rule_prefs, param => {} );
  unless ( defined $docref ) {
    remark(
      'error',
      'could not parse document',
      { file => $file, errno => $xapply->errorstring }
    );
    exit 101;
  }

  # TODO need to chdir or similar for the output files?
  my $output_file;
  if ( exists $opts{o} ) {
    ( $output_file = $opts{o} ) =~
     s/ %{ (\w+) } / $filedata->{$1} || $rule_prefs->{$1} || '' /egx;

    # TODO use IO::Atomic or something?
    open OUTPUT, "> $output_file"
     or remark(
      'error',
      'could not write to file',
      { file => $output_file, errno => $! }
     )
     and exit 102;
    select OUTPUT;
  }

  # TODO need autoflush if no newlines on end?
  print $$docref;

  if ( exists $opts{o} ) {
    close OUTPUT
     or remark(
      'error',
      'could not close write to file',
      { file => $output_file, errno => $! }
     )
     and exit 102;
  }
}

# TODO need this??
sub load_prefs {
  my $file = shift;

  open my $fh, "< $file"
   or remark( 'error', 'could not load preferences', { file => $file } )
   and exit 101;

  my %data;
  my %tmp = %defaults;

  while (<$fh>) {
    s/^\s+//;
    next if /^#/;
    chomp;

    if (/^$/) {
      pref_finish( \%tmp, \%data ) if exists $tmp{name};
      next;
    }

    s/\s+$//;

    my ( $k, $v ) = split /\s+/, $_, 2;
    unless ( defined $k and $k =~ /^[\w.-]+$/ and defined $v ) {
      remark(
        'warning',
        'skipping invalid data',
        { file => $file, line => $. }
      );
      next;
    }
    $tmp{$k} = $v;
  }
  pref_finish( \%tmp, \%data ) if exists $tmp{name};

  return \%data;
}

sub pref_finish {
  my $tmp  = shift;
  my $data = shift;

  if ( exists $tmp->{suffix} ) {
    $tmp->{suffix} = [ map { s/^\.//; $_ } split / /, $tmp->{suffix} ];
  }

  push @{ $data->{ $tmp->{class} } }, {%$tmp};

  if ( exists $tmp->{suffix} ) {
    for my $suffix ( @{ $tmp->{suffix} } ) {
      push @{ $data->{_suffixmap}->{ $tmp->{class} }->{$suffix} },
       $#{ $data->{ $tmp->{class} } };
    }
  }

  %$tmp = %defaults;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
  my @pathes = @_;
  for (@pathes) {
    s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam $1)[7] : (getpwuid $<)[7] || $ENV{HOME}
        || remark('error',
             'could not lookup user or HOME not set',
             { file => $_ })
        && exit 99;
     }ex;
  }
  return wantarray ? @pathes : "@pathes";
}

sub print_help {
  print <<"HELP";
Usage: $basename [options] file [file2 ...]

Applies XSLT styleseets to XML data.

Options:
  -h/-?  Display this message.

Run perldoc(1) on this script for additional documentation.

HELP
  exit 100;
}

sub remark {
  my $priority   = shift;
  my $message    = shift;
  my $attributes = shift;

  chomp $message;

  my $attr_str;
  if ($attributes) {
    $attr_str = join ', ',
     map { $attributes->{$_} ||= ''; "$_=$attributes->{$_}" }
     sort keys %$attributes;
  }

  print STDERR "$priority: $message"
   . ( $attr_str ? ": $attr_str" : '' ) . "\n";
  return 1;
}

__END__

=head1 NAME

axp - applies XSLT styleseets to XML data

=head1 SYNOPSIS

TODO

  $ axp

=head1 DESCRIPTION

=head2 Overview

TODO

=head2 Normal Usage

  $ axp [options] file [file2 ...]

See L<"OPTIONS"> for details on the command line switches supported.

TODO

=head1 OPTIONS

This script currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note about the script.

=back

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this script may be available from:

http://sial.org/code/perl/

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

No known issues.

=head1 SEE ALSO

perl(1), XML::ApplyXSLT

=head1 AUTHOR

Jeremy Mates, http://sial.org/contact/

=head1 COPYRIGHT

The author disclaims all copyrights and releases this script into the
public domain.

=head1 VERSION

  $Id$

=cut
