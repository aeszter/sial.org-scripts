#!/usr/bin/perl -w
#
# $Id$
#
# The author disclaims all copyrights and releases this script into the
# public domain.
#
# Utility to manage and maintain OpenSSH known_hosts data.

use strict;
use Fatal qw(open close);

use Getopt::Std;
my %opts;
getopts 'mM', \%opts;

my $khf   = shift;
my $extra = shift;

open my $file, "< $khf";
my $hkd = parse_known_hosts($file);

if ($extra) {
  my $ehkd;
  if ( $extra eq '-' ) {
    $ehkd = parse_known_hosts( \*STDIN );
  } else {
    open my $file, "< $extra";
    $ehkd = parse_known_hosts($file);
  }
  $hkd = resolve_host_keys( $hkd, $ehkd );
}

if ( $opts{'M'} ) {
  $hkd = unmerge_host_keys($hkd);
} elsif ( $opts{'m'} or $extra ) {
  $hkd = merge_host_keys($hkd);
}

print_known_hosts($hkd);

sub resolve_host_keys {
  my $hkd  = unmerge_host_keys(shift);
  my $ehkd = unmerge_host_keys(shift);

  my ( %hostmap, %keymap );
  for my $i ( 0 .. $#$hkd ) {
    my $hkr = $hkd->[$i];
    push @{ $keymap{"$hkr->{'key_type'} $hkr->{'public_key'}"} }, $i;
  }

  for my $i ( 0 .. $#$hkd ) {
    my $hkr = $hkd->[$i];

    for my $host ( @{ $hkr->{'hosts'} } ) {
      push @{ $hostmap{"$hkr->{'key_type'} $host"} }, $i,
       @{ $keymap{"$hkr->{'key_type'} $hkr->{'public_key'}"} };
    }
  }

  my %delete;
  for my $hkr (@$ehkd) {
    for my $host ( @{ $hkr->{'hosts'} } ) {
      if ( exists $hostmap{"$hkr->{'key_type'} $host"} ) {
        $delete{$_} = 1 for @{ $hostmap{"$hkr->{'key_type'} $host"} };
      }
    }
  }
  delete @{$hkd}[ keys %delete ];
  @$hkd = grep defined, @$hkd;

  push @$hkd, @$ehkd;

  return $hkd;
}

sub print_known_hosts {
  my $hkd = shift;

  for my $hkr ( sort { $a->{'hosts'}->[0] cmp $b->{'hosts'}->[0] } @$hkd ) {
    my $host_spec = join ',', @{ $hkr->{'hosts'} };
    print join( ' ', $host_spec, $hkr->{'key_type'}, $hkr->{'public_key'} ),
     "\n";
  }
}

sub unmerge_host_keys {
  my $hkd = shift;
  my @host_keys;
  for my $hkr (@$hkd) {
    my @hosts = @{ $hkr->{'hosts'} };
    delete $hkr->{'hosts'};
    for my $host (@hosts) {
      push @host_keys, { hosts => [$host], (%$hkr) };
    }
  }
  return \@host_keys;
}

# takes hostname => public_key hash reference, returns new hash
# reference with hostnames merged on identical public keys
sub merge_host_keys {
  my $hkd = shift;

  my ( %keys2hosts, @host_keys );

  for my $hkr (@$hkd) {
    push @{ $keys2hosts{"$hkr->{key_type} $hkr->{public_key}"} },
     @{ $hkr->{'hosts'} };
  }

  for my $key ( keys %keys2hosts ) {
    my ( $key_type, $public_key ) = split ' ', $key, 2;
    push @host_keys,
     {
      key_type   => $key_type,
      public_key => $public_key,
      hosts      => [ sort { $b cmp $a } @{ $keys2hosts{$key} } ]
     };
  }

  return \@host_keys;
}

# parses OpenSSH known_hosts file into array of hash references
sub parse_known_hosts {
  my $what = shift;

  my @host_keys;

  # by filehandle
  if ( ref $what eq 'GLOB' ) {
    while (<$what>) {
      next if /^#/;
      chomp;
      my ( $host_spec, $key_type, $public_key ) = split ' ', $_, 3;
      next unless $host_spec and $key_type and $public_key;

      push @host_keys,
       {
        key_type   => $key_type,
        public_key => $public_key,
        hosts      => [ sort { $b cmp $a } split ',', $host_spec ],
        line       => $.
       };
    }
  } else {
    die "error: do not know how to parse known_hosts from ", ref $what;
  }

  return \@host_keys;
}
